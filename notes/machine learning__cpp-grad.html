<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>cpp-grad</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/584705cbbef33b49.css" as="style"/><link rel="stylesheet" href="/_next/static/css/584705cbbef33b49.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-83cebdb887f48834.js" defer=""></script><script src="/_next/static/chunks/pages/_app-eb98586f475796ed.js" defer=""></script><script src="/_next/static/chunks/247-fb3f3c148c859656.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bnote_id%5D-774c61eb2a4693cc.js" defer=""></script><script src="/_next/static/0cQi27foYwZlvrxIm4tXk/_buildManifest.js" defer=""></script><script src="/_next/static/0cQi27foYwZlvrxIm4tXk/_ssgManifest.js" defer=""></script></head><body class="dark:bg-black dark:bg-opacity-95"><div id="__next"><div><nav class="md:sticky md:top-0 md:z-40 shadow-sm p-2 bg-white dark:bg-black dark:shadow-lg dark:shadow-stone-800"><div class="flex items-center"><a class="flex" href="/"><img alt="Profile pic" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="rounded-full h-20 w-20 mx-2" style="color:transparent" src="/pfp_blank.png"/><h1 class="self-center text-xl text-stone-400 font-mono dark:text-stone-50 dark:drop-shadow-2xl dark:shadow-white dark:hover:text-stone-200">krkartikay&#x27;s notes</h1></a></div></nav><div class="flex flex-row flex-wrap"><aside class="md:w-1/4 text-stone-500 dark:text-stone-200"><div class="max-w-md mx-auto py-8"><a href="/"><h2 class="p-8 text-lg text-stone-600 hover:bg-stone-100 dark:text-stone-200 dark:hover:bg-stone-800 dark:hover:text-stone-200 ">Notes</h2></a><ul class="list-disc pl-8"><a href="/notes/book%20notes__index"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Book Notes</li></a><ul class="list-disc pl-8"><a href="/notes/book%20notes__if"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">&quot;If&quot;</li></a><a href="/notes/book%20notes__dokkodo"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Dokkodo</li></a><a href="/notes/book%20notes__the%20bhagvad%20gita__index"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">The Bhagvad Gita</li></a><ul class="list-disc pl-8"><a href="/notes/book%20notes__the%20bhagvad%20gita__chapter_1"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Chapter 1</li></a><a href="/notes/book%20notes__the%20bhagvad%20gita__chapter_2"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Chapter 2</li></a></ul><a href="/notes/book%20notes__worry"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Worry</li></a></ul><a href="/notes/economics__index"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Economics</li></a><ul class="list-disc pl-8"><a href="/notes/economics__microeconomics__index"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Microeconomics</li></a><ul class="list-disc pl-8"><a href="/notes/economics__microeconomics__lecture_1"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Lecture 1</li></a><a href="/notes/economics__microeconomics__lecture_2"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Lecture 2</li></a><a href="/notes/economics__microeconomics__lecture_3"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Lecture 3</li></a><a href="/notes/economics__microeconomics__lecture_4"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Lecture 4</li></a><a href="/notes/economics__microeconomics__lecture_5"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Lecture 5</li></a><a href="/notes/economics__microeconomics__lecture_6"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Lecture 6</li></a></ul></ul><a href="/notes/machine%20learning__index"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Machine Learning</li></a><ul class="list-disc pl-8"><a href="/notes/machine%20learning__alpha%20zero__index"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Alpha Zero</li></a><ul class="list-disc pl-8"><a href="/notes/machine%20learning__alpha%20zero__1-the-start"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">1. The Start</li></a><a href="/notes/machine%20learning__alpha%20zero__2-initial-plan"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">2. Initial plan</li></a><a href="/notes/machine%20learning__alpha%20zero__3-supervised-learning"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">3. Supervised Learning</li></a><a href="/notes/machine%20learning__alpha%20zero__4-experimentation"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">4. Experimentation Framework</li></a><a href="/notes/machine%20learning__alpha%20zero__5-visualization"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">5. Visualization</li></a><a href="/notes/machine%20learning__alpha%20zero___notes"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">_notes</li></a></ul><a href="/notes/machine%20learning__karpathy-lectures"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Andrey Karpathy&#x27;s Lectures</li></a><a href="/notes/machine%20learning__study-plan"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">ML Study plan</li></a><a href="/notes/machine%20learning__cpp-grad"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside font-bold bg-stone-50 dark:bg-stone-800">cpp-grad</li></a></ul><a href="/notes/quotes"><li class="py-2 pl-2 hover:bg-stone-100 hover:text-stone-600 dark:text-stone-400 dark:hover:bg-stone-800 dark:hover:text-stone-200 list-inside ">Quotes</li></a></ul></div></aside><main class="md:w-3/4 border-l-2 dark:border-l-stone-900 border-l-stone-50"><div class="p-8 md:p-16"><br/><h1 class="text-4xl dark:text-white">cpp-grad</h1><p class="text-stone-400 dark:text-stone-300">2023-04-17</p><div class="prose prose-stone dark:prose-invert"><div><hr>
<h1>Reimplementing Micrograd in C++</h1>
<h2>Part 1 â€“ An unexpected error</h2>
<p>I was watching <a href="https://www.youtube.com/watch?v=VMj-3S1tku0">Andrej Karpathy's lecture on micrograd</a> and decided to implement a micrograd-like library in C++. It feels only natural to implement it in C++ because the operations will be more efficient in C++. Also I'd get a chance to write some more C++ code and use some more object oriented features of C++ like operator overloading.</p>
<p>So at first I naively started implementing micrograd, basically doing what Andrej was doing in Python and mentally translating it into C++ code. However at one point I got stuck on an interesting error.</p>
<h3>The code</h3>
<p>The initial part of micrograd is basically about creating an expression graph of variables and operators and using that expression graph to then traverse backward and update the gradients. I had basically created the expression graph and was trying to print it out while traversing it recursively that I noticed a problem.</p>
<p>Here's the code I had till then:</p>
<p><code>main.cpp</code></p>
<pre><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;iostream></span></span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"engine.h"</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-function">Value <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2.0</span>)</span></span>;
  <span class="hljs-function">Value <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">-3.0</span>)</span></span>;
  <span class="hljs-function">Value <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">10.0</span>)</span></span>;
  Value d = a * b + c;
  std::cout &#x3C;&#x3C; d.<span class="hljs-built_in">dbg</span>() &#x3C;&#x3C; <span class="hljs-string">"\n"</span>;
}
</code></pre>
<p><code>engine.h</code></p>
<pre><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;iostream></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;ostream></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;set></span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Value</span> {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Value</span><span class="hljs-params">(<span class="hljs-type">double</span> data)</span> : data_(data) {</span>}

  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Value</span><span class="hljs-params">(<span class="hljs-type">double</span> data, std::set&#x3C;<span class="hljs-type">const</span> Value *> prev, <span class="hljs-type">char</span> op)</span>
      : data_(data), prev_(prev), op_(op){</span>};

  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">data</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> data_; }

  <span class="hljs-keyword">friend</span> std::ostream &#x26;<span class="hljs-keyword">operator</span>&#x3C;&#x3C;(std::ostream &#x26;out, Value v);

  Value <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Value &#x26;other) <span class="hljs-type">const</span>;
  Value <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Value &#x26;other) <span class="hljs-type">const</span>;

  <span class="hljs-function">std::string <span class="hljs-title">dbg</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;

 <span class="hljs-keyword">private</span>:
  <span class="hljs-type">double</span> data_ = <span class="hljs-number">0</span>;
  std::set&#x3C;<span class="hljs-type">const</span> Value *> prev_;
  <span class="hljs-type">char</span> op_ = <span class="hljs-number">0</span>;
};
</code></pre>
<p><code>engine.cpp</code></p>
<pre><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"engine.h"</span></span>

std::ostream &#x26;<span class="hljs-keyword">operator</span>&#x3C;&#x3C;(std::ostream &#x26;out, Value v) {
  <span class="hljs-keyword">return</span> out &#x3C;&#x3C; <span class="hljs-string">"Value("</span> &#x3C;&#x3C; v.<span class="hljs-built_in">data</span>() &#x3C;&#x3C; <span class="hljs-string">")"</span>;
}

Value Value::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Value &#x26;other) <span class="hljs-type">const</span> {
  Value out = <span class="hljs-built_in">Value</span>(<span class="hljs-built_in">data</span>() + other.<span class="hljs-built_in">data</span>(), {<span class="hljs-keyword">this</span>, &#x26;other}, <span class="hljs-string">'*'</span>);
  <span class="hljs-keyword">return</span> out;
}

Value Value::<span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Value &#x26;other) <span class="hljs-type">const</span> {
  Value out = <span class="hljs-built_in">Value</span>(<span class="hljs-built_in">data</span>() * other.<span class="hljs-built_in">data</span>(), {<span class="hljs-keyword">this</span>, &#x26;other}, <span class="hljs-string">'*'</span>);
  <span class="hljs-keyword">return</span> out;
}

<span class="hljs-function">std::string <span class="hljs-title">Value::dbg</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
  <span class="hljs-keyword">if</span> (op_) {
    std::string children_dbg;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Value *v : prev_) {
      children_dbg += v-><span class="hljs-built_in">dbg</span>() + <span class="hljs-string">", "</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Value(data="</span> + std::<span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">data</span>()) + <span class="hljs-string">",op="</span> + op_ +
           <span class="hljs-string">",prev={"</span> + children_dbg + <span class="hljs-string">"})"</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Value(data="</span> + std::<span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">data</span>()) + <span class="hljs-string">")"</span>;
}
</code></pre>
<p>(Note that Andrej did not define a <code>dbg</code> function like me, instead he had defined a couple of functions to print out the graph in a graphviz format which also renders it in the jupyter notebook, but since I was doing it in C++, the <code>dbg</code> function would have to do for now.)</p>
<h3>The problem:</h3>
<pre><code class="hljs language-sh">@krkartikay âžœ /workspaces/cpp-grad (main) $ make &#x26;&#x26; ./main
g++ main.cpp engine.cpp nn.cpp -o main
Segmentation fault (core dumped)
</code></pre>
<p>So, can you figure out what went wrong? There's only one place where the crash could happen, when we call <code>v->dbg()</code> and dereference the pointer <code>v</code>, because there is no other place where we're dereferencing a pointer. But why did it crash? It looks like we're initialising the pointers with the correct values, and there shouldn't be any <code>nullptr</code>s anywhere. So what's the problem then?</p>
<p>Here's a hint, the code worked when I changed the following lines in <code>main.cpp</code>:</p>
<pre><code class="hljs language-cpp">  Value d = a * b + c;
  std::cout &#x3C;&#x3C; d.<span class="hljs-built_in">dbg</span>() &#x3C;&#x3C; <span class="hljs-string">"\n"</span>;
</code></pre>
<p>to this:</p>
<pre><code class="hljs language-cpp">  Value d = a * b;
  Value e = d + c;
  std::cout &#x3C;&#x3C; e.<span class="hljs-built_in">dbg</span>() &#x3C;&#x3C; <span class="hljs-string">"\n"</span>;
</code></pre>
<p>And this was the output then:</p>
<pre><code>@krkartikay âžœ /workspaces/cpp-grad (main) $ make &#x26;&#x26; ./main
g++ main.cpp engine.cpp nn.cpp -o main
Value(data=4.000000,op=*,prev={Value(data=10.000000), Value(data=-6.000000,op=*,prev={Value(data=2.000000), Value(data=-3.000000), }), })
</code></pre>
<p>So here's basically what's happening. When we are evaluating <code>a * b + c</code>, <code>(a * b)</code> first creates a temporary object that gets added with <code>c</code> and the node <code>d</code> (the output node) contains a pointer to the temporary object <code>(a * b)</code>. This temporary object gets destructed as soon as the expression finishes evaluating and we reach the next line (<code>d.dbg()</code>). So when we call <code>v->dbg()</code> on this node, the <code>v</code> pointer points to a destructed object. This is a problem that wouldn't happen in Python because all objects are created on the heap and the garbage collector takes care of reference counting and doesn't delete this object as it still has one reference.</p>
<h3>The solution</h3>
<p>So how do we solve this problem? I got stuck on this problem because while I understood what's going wrong, the best solution wasn't immediately obvious to me. However after some thinking I decided that maybe doing something like what Python does is the best approach. We can let the Value class be a wrapper for a smart-pointer like object, which creates the actual object on the heap and does the reference counting, while it also has the right operator-overloads for writing expressions like this.</p>
<p>I wanted to write code to fix this problem, but then I thought it was too boring. Let's ask ChatGPT instead? I first wanted to see if GPT-4 understands the problem. I gave it all the above text up to the point where I ask, "So, can you figure out what went wrong?".</p>
<p>Here's what it gave me:</p>
<blockquote>
<p>It looks like you are running into a segmentation fault while trying to print the expression graph. The segmentation fault usually occurs when a program tries to access memory that it is not allowed to. In your case, it seems to be related to the recursive traversal of the expression graph when calling the <code>dbg()</code> function.</p>
<p>After analyzing your code, I have noticed an issue in the Value::operator+ function:</p>
<pre><code class="hljs language-cpp">Value Value::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Value &#x26;other) <span class="hljs-type">const</span> {
  Value out = <span class="hljs-built_in">Value</span>(<span class="hljs-built_in">data</span>() + other.<span class="hljs-built_in">data</span>(), {<span class="hljs-keyword">this</span>, &#x26;other}, <span class="hljs-string">'*'</span>);
  <span class="hljs-keyword">return</span> out;
}
</code></pre>
<p>Here, you are initializing out with an <code>op_</code> value of '*', which should be '+' instead, as this is the addition operator. However, this is not the primary cause of the segmentation fault.</p>
<p>The main issue lies in the fact that you are storing pointers to local Value objects in the <code>prev_</code> set. When you create a new Value object inside the <code>operator+</code> and <code>operator*</code> functions, these objects have local scope and will be destroyed once the function returns. As a result, the pointers stored in the <code>prev_</code> set of the parent Value object will become dangling pointers, pointing to invalid memory locations.</p>
<p>To fix the issue, you need to manage the memory for the Value objects more carefully. One way to do this is to use dynamic memory allocation with smart pointers. You can use <code>std::shared_ptr</code> to manage the memory of Value objects, which will automatically deallocate the memory when there are no more references to the object.</p>
<p>Here's an updated version of your code using <code>std::shared_ptr</code>: ...</p>
</blockquote>
<p>It did find out the issue and fix it! That too in the first try. I'm impressed! And it even found an unrelated mistake. I bet you didn't see that either. The solution it suggested was something like this, to modify the Value class to hold a set of <code>shared_ptr</code>'s instead:</p>
<pre><code class="hljs language-cpp">std::set&#x3C;std::shared_ptr&#x3C;<span class="hljs-type">const</span> Value>> prev_;
</code></pre>
<p>and to define the operators like this:</p>
<pre><code class="hljs language-cpp">Value Value::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Value &#x26;other) <span class="hljs-type">const</span> {
  Value out = <span class="hljs-built_in">Value</span>(<span class="hljs-built_in">data</span>() + other.<span class="hljs-built_in">data</span>(),
                    {std::<span class="hljs-built_in">make_shared</span>&#x3C;Value>(*<span class="hljs-keyword">this</span>),
                     std::<span class="hljs-built_in">make_shared</span>&#x3C;Value>(other)}, <span class="hljs-string">'+'</span>);
  <span class="hljs-keyword">return</span> out;
}
</code></pre>
<p>However I was worried with this solution that it may create duplicate nodes and not understand that some nodes are shared. I asked it to explain the difference between <code>shared_ptr</code> and <code>unique_ptr</code> and this is what it told me:</p>
<blockquote>
<p><code>std::shared_ptr</code> is a smart pointer provided by the C++ Standard Library that manages shared ownership of a dynamically allocated object. It keeps track of the number of <code>shared_ptr</code> instances referring to the same object, using reference counting. When the last <code>shared_ptr</code> that owns the object is destroyed or reset, the object is automatically deleted.</p>
<p>In the updated program, <code>std::shared_ptr</code> ensures that the temporary <code>Value</code> objects are not deleted prematurely by managing their lifetime based on reference counts. When you create a <code>shared_ptr</code> for a Value object inside the operator+ and operator* functions, the reference count for the object is increased. These <code>shared_ptr</code> instances are then stored in the <code>prev_</code> set of the parent Value object. As long as there is at least one <code>shared_ptr</code> referring to the object, it won't be deleted.</p>
<p>When the parent Value object is destroyed or goes out of scope, the <code>shared_ptr</code> instances in the <code>prev_</code> set are also destroyed, which in turn decreases the reference count for the child Value objects. If the reference count reaches zero, the object is deleted automatically, ensuring proper memory management.</p>
<p><code>std::unique_ptr</code> is another smart pointer provided by the C++ Standard Library that manages the exclusive ownership of a dynamically allocated object. Unlike <code>std::shared_ptr</code>, it doesn't use reference counting, as it is designed to have only one owner at a time. When a unique_ptr is destroyed or reset, the object it owns is automatically deleted.</p>
<p>The main differences between <code>std::shared_ptr</code> and <code>std::unique_ptr</code> are:</p>
<ol>
<li>Ownership: <code>std::shared_ptr</code> allows shared ownership, meaning multiple <code>shared_ptr</code> instances can own the same object. In contrast, <code>std::unique_ptr</code> enforces exclusive ownership, with only one <code>unique_ptr</code> owning the object at any given time.</li>
<li>Reference counting: <code>std::shared_ptr</code> uses reference counting to keep track of the number of instances owning the same object. This adds some overhead compared to <code>std::unique_ptr</code>, which doesn't use reference counting.</li>
<li>Copying and assignment: <code>std::shared_ptr</code> can be copied and assigned to other <code>shared_ptr</code> instances, which increases the reference count. <code>std::unique_ptr</code> cannot be copied, but it can be moved using <code>std::move</code>, transferring ownership to another <code>unique_ptr</code>.</li>
<li>In the provided example, <code>std::shared_ptr</code> is more suitable because the expression graph requires shared ownership of the Value objects, and the lifetime of the objects needs to be managed based on reference counts. <code>std::unique_ptr</code> wouldn't be appropriate in this case, as it enforces exclusive ownership and doesn't support reference counting.</li>
</ol>
</blockquote>
<p>I also asked it about my wrapper solution, and here's what it said:</p>
<blockquote>
<p>Would it be better if instead of modifying the Value class to hold shared_ptrs in the <code>prev_</code> set, I create a new set of nodes elsewhere and let the Value class be a wrapper for a <code>shared_ptr</code> pointing to a <code>ValueNode</code> in the set?</p>
</blockquote>
<blockquote>
<p>Yes, that could be a good alternative design. By creating a separate set of nodes elsewhere and making the Value class a wrapper for a shared_ptr pointing to a ValueNode in the set, you can achieve the desired behavior while keeping the Value class simpler and more focused on its purpose.</p>
</blockquote>
<blockquote>
<p>Here's a possible implementation of this design: ...</p>
</blockquote>
<p>I also tried asking it for various other modifications like adding a tagging functionality etc, and it did all of it perfectly.
This is the final code I got, written entirely* by GPT-4:</p>
<p>[* Of course the GPT-4 output did not compile directly. It even had a couple of minor syntax errors. But I only had to change a few lines to fix it, it had gotten very close to the solution. But then I wouldn't expect even my own code to compile on first try.]</p>
<p><code>main.cpp</code></p>
<pre><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;iostream></span></span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"value.h"</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-function">Value <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2.0</span>)</span></span>;
  Value b = a; <span class="hljs-comment">// b shares the same underlying ValueNode as a</span>
  Value c = b * a;
  std::cout &#x3C;&#x3C; <span class="hljs-string">"a: "</span> &#x3C;&#x3C; a.<span class="hljs-built_in">dbg</span>() &#x3C;&#x3C; <span class="hljs-string">"\n"</span>;
  std::cout &#x3C;&#x3C; <span class="hljs-string">"b: "</span> &#x3C;&#x3C; b.<span class="hljs-built_in">dbg</span>() &#x3C;&#x3C; <span class="hljs-string">"\n"</span>;
  std::cout &#x3C;&#x3C; <span class="hljs-string">"c: "</span> &#x3C;&#x3C; c.<span class="hljs-built_in">dbg</span>() &#x3C;&#x3C; <span class="hljs-string">"\n"</span>;

  <span class="hljs-function">Value <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">3.0</span>)</span></span>;
  Value e = d * d;
  std::cout &#x3C;&#x3C; <span class="hljs-string">"d: "</span> &#x3C;&#x3C; d.<span class="hljs-built_in">dbg</span>() &#x3C;&#x3C; <span class="hljs-string">"\n"</span>;
  std::cout &#x3C;&#x3C; <span class="hljs-string">"e: "</span> &#x3C;&#x3C; e.<span class="hljs-built_in">dbg</span>() &#x3C;&#x3C; <span class="hljs-string">"\n"</span>;
  
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p><code>value.h</code></p>
<pre><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;memory></span></span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"value_node.h"</span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Value</span> {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Value</span><span class="hljs-params">(<span class="hljs-type">double</span> data)</span></span>;

  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">data</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;

  <span class="hljs-keyword">friend</span> std::ostream &#x26;<span class="hljs-keyword">operator</span>&#x3C;&#x3C;(std::ostream &#x26;out, <span class="hljs-type">const</span> Value &#x26;v);

  Value <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Value &#x26;other) <span class="hljs-type">const</span>;
  Value <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Value &#x26;other) <span class="hljs-type">const</span>;

  <span class="hljs-function">std::string <span class="hljs-title">dbg</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;

 <span class="hljs-keyword">private</span>:
  <span class="hljs-built_in">Value</span>();
  std::shared_ptr&#x3C;ValueNode> node_;
};
</code></pre>
<p><code>value.cpp</code></p>
<pre><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"value.h"</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;set></span></span>

Value::<span class="hljs-built_in">Value</span>(<span class="hljs-type">double</span> data)
    : <span class="hljs-built_in">node_</span>(std::<span class="hljs-built_in">make_shared</span>&#x3C;ValueNode>(data)) {}

Value::<span class="hljs-built_in">Value</span>() {}

<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Value::data</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> node_-><span class="hljs-built_in">data</span>(); }

std::ostream &#x26;<span class="hljs-keyword">operator</span>&#x3C;&#x3C;(std::ostream &#x26;out, <span class="hljs-type">const</span> Value &#x26;v) {
  <span class="hljs-keyword">return</span> out &#x3C;&#x3C; <span class="hljs-string">"Value("</span> &#x3C;&#x3C; v.<span class="hljs-built_in">data</span>() &#x3C;&#x3C; <span class="hljs-string">")"</span>;
}

Value Value::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Value &#x26;other) <span class="hljs-type">const</span> {
  <span class="hljs-keyword">auto</span> node = std::<span class="hljs-built_in">make_shared</span>&#x3C;ValueNode>(
      <span class="hljs-built_in">data</span>() + other.<span class="hljs-built_in">data</span>(),
      std::set&#x3C;std::shared_ptr&#x3C;ValueNode>>({node_, other.node_}),
      <span class="hljs-string">'+'</span>);
  Value out;
  out.node_ = node;
  <span class="hljs-keyword">return</span> out;
}

Value Value::<span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Value &#x26;other) <span class="hljs-type">const</span> {
  <span class="hljs-keyword">auto</span> node = std::<span class="hljs-built_in">make_shared</span>&#x3C;ValueNode>(
      <span class="hljs-built_in">data</span>() * other.<span class="hljs-built_in">data</span>(),
      std::set&#x3C;std::shared_ptr&#x3C;ValueNode>>({node_, other.node_}),
      <span class="hljs-string">'*'</span>);
  Value out;
  out.node_ = node;
  <span class="hljs-keyword">return</span> out;
}

<span class="hljs-function">std::string <span class="hljs-title">Value::dbg</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> node_-><span class="hljs-built_in">dbg</span>(); }
</code></pre>
<p><code>value_node.h</code></p>
<pre><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;iostream></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;memory></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;set></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;string></span></span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ValueNode</span> {
 <span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ValueNode</span><span class="hljs-params">(<span class="hljs-type">double</span> data)</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ValueNode</span><span class="hljs-params">(<span class="hljs-type">double</span> data,
                     std::set&#x3C;std::shared_ptr&#x3C;ValueNode>> prev,
                     <span class="hljs-type">char</span> op)</span></span>;

  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">data</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;
  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;

  <span class="hljs-function">std::string <span class="hljs-title">dbg</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;

 <span class="hljs-keyword">private</span>:
  <span class="hljs-type">int</span> id_;
  <span class="hljs-type">double</span> data_ = <span class="hljs-number">0</span>;
  std::set&#x3C;std::shared_ptr&#x3C;ValueNode>> prev_;
  <span class="hljs-type">char</span> op_ = <span class="hljs-number">0</span>;

  <span class="hljs-type">static</span> <span class="hljs-type">int</span> next_id_;
};
</code></pre>
<p><code>value_node.cpp</code></p>
<pre><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"value_node.h"</span></span>

<span class="hljs-type">int</span> ValueNode::next_id_ = <span class="hljs-number">0</span>;

ValueNode::<span class="hljs-built_in">ValueNode</span>(<span class="hljs-type">double</span> data) : <span class="hljs-built_in">id_</span>(next_id_++), <span class="hljs-built_in">data_</span>(data) {}

ValueNode::<span class="hljs-built_in">ValueNode</span>(<span class="hljs-type">double</span> data,
                     std::set&#x3C;std::shared_ptr&#x3C;ValueNode>> prev,
                     <span class="hljs-type">char</span> op)
    : <span class="hljs-built_in">id_</span>(next_id_++), <span class="hljs-built_in">data_</span>(data), <span class="hljs-built_in">prev_</span>(prev), <span class="hljs-built_in">op_</span>(op) {}

<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">ValueNode::data</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> data_; }

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ValueNode::id</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{ <span class="hljs-keyword">return</span> id_; }

<span class="hljs-function">std::string <span class="hljs-title">ValueNode::dbg</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
  <span class="hljs-keyword">if</span> (op_) {
    std::string children_dbg;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &#x26;v : prev_) {
      children_dbg += v-><span class="hljs-built_in">dbg</span>() + <span class="hljs-string">", "</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">"ValueNode(id="</span> + std::<span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">id</span>()) +
           <span class="hljs-string">",data="</span> + std::<span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">data</span>()) + <span class="hljs-string">",op="</span> + op_ +
           <span class="hljs-string">",prev={"</span> + children_dbg + <span class="hljs-string">"})"</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-string">"ValueNode(id="</span> + std::<span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">id</span>()) +
         <span class="hljs-string">",data="</span> + std::<span class="hljs-built_in">to_string</span>(<span class="hljs-built_in">data</span>()) + <span class="hljs-string">")"</span>;
}
</code></pre>
<h4>GPT-4's predicted output:</h4>
<pre><code class="hljs language-cpp">a: <span class="hljs-built_in">ValueNode</span>(id=<span class="hljs-number">0</span>,data=<span class="hljs-number">2</span>)
b: <span class="hljs-built_in">ValueNode</span>(id=<span class="hljs-number">0</span>,data=<span class="hljs-number">2</span>)
c: <span class="hljs-built_in">ValueNode</span>(id=<span class="hljs-number">1</span>,data=<span class="hljs-number">4</span>,op=*,prev={<span class="hljs-built_in">ValueNode</span>(id=<span class="hljs-number">0</span>,data=<span class="hljs-number">2</span>), <span class="hljs-built_in">ValueNode</span>(id=<span class="hljs-number">0</span>,data=<span class="hljs-number">2</span>)})
d: <span class="hljs-built_in">ValueNode</span>(id=<span class="hljs-number">2</span>,data=<span class="hljs-number">3</span>)
e: <span class="hljs-built_in">ValueNode</span>(id=<span class="hljs-number">3</span>,data=<span class="hljs-number">9</span>,op=*,prev={<span class="hljs-built_in">ValueNode</span>(id=<span class="hljs-number">2</span>,data=<span class="hljs-number">3</span>), <span class="hljs-built_in">ValueNode</span>(id=<span class="hljs-number">2</span>,data=<span class="hljs-number">3</span>)})
</code></pre>
<h4>Actual Output:</h4>
<pre><code class="hljs language-cpp">a: <span class="hljs-built_in">ValueNode</span>(id=<span class="hljs-number">0</span>,data=<span class="hljs-number">2.000000</span>)
b: <span class="hljs-built_in">ValueNode</span>(id=<span class="hljs-number">0</span>,data=<span class="hljs-number">2.000000</span>)
c: <span class="hljs-built_in">ValueNode</span>(id=<span class="hljs-number">1</span>,data=<span class="hljs-number">4.000000</span>,op=*,prev={<span class="hljs-built_in">ValueNode</span>(id=<span class="hljs-number">0</span>,data=<span class="hljs-number">2.000000</span>), })
d: <span class="hljs-built_in">ValueNode</span>(id=<span class="hljs-number">2</span>,data=<span class="hljs-number">3.000000</span>)
e: <span class="hljs-built_in">ValueNode</span>(id=<span class="hljs-number">3</span>,data=<span class="hljs-number">9.000000</span>,op=*,prev={<span class="hljs-built_in">ValueNode</span>(id=<span class="hljs-number">2</span>,data=<span class="hljs-number">3.000000</span>), })
</code></pre>
<h3>Bonus?</h3>
<pre><code class="hljs language-cpp"><span class="hljs-comment">// Add these includes at the beginning of the file</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;sstream></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;unordered_set></span></span>

<span class="hljs-comment">// Add this function declaration in the `Value` class</span>
<span class="hljs-function">std::string <span class="hljs-title">to_graphviz</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;
</code></pre>
<pre><code class="hljs language-cpp"><span class="hljs-comment">// Helper function for the recursive traversal</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse_graphviz</span><span class="hljs-params">(<span class="hljs-type">const</span> Value &#x26;v, std::unordered_set&#x3C;<span class="hljs-type">const</span> Value *> &#x26;visited, std::stringstream &#x26;ss)</span> </span>{
  <span class="hljs-keyword">if</span> (visited.<span class="hljs-built_in">count</span>(&#x26;v) == <span class="hljs-number">0</span>) {
    visited.<span class="hljs-built_in">insert</span>(&#x26;v);

    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &#x26;prev : v.prev_) {
      ss &#x3C;&#x3C; <span class="hljs-string">"\""</span> &#x3C;&#x3C; prev->id_ &#x3C;&#x3C; <span class="hljs-string">"\" -> \""</span> &#x3C;&#x3C; v.id_ &#x3C;&#x3C; <span class="hljs-string">"\";\n"</span>;
      <span class="hljs-built_in">traverse_graphviz</span>(*prev, visited, ss);
    }

    ss &#x3C;&#x3C; <span class="hljs-string">"\""</span> &#x3C;&#x3C; v.id_ &#x3C;&#x3C; <span class="hljs-string">"\" [label=\"Value(id="</span> &#x3C;&#x3C; v.id_ &#x3C;&#x3C; <span class="hljs-string">", data="</span> &#x3C;&#x3C; v.data_ &#x3C;&#x3C; <span class="hljs-string">", op="</span> &#x3C;&#x3C; (v.op_ ? v.op_ : <span class="hljs-string">' '</span>) &#x3C;&#x3C; <span class="hljs-string">")\"];\n"</span>;
  }
}

<span class="hljs-comment">// to_graphviz function implementation</span>
<span class="hljs-function">std::string <span class="hljs-title">Value::to_graphviz</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>{
  std::stringstream ss;
  std::unordered_set&#x3C;<span class="hljs-type">const</span> Value *> visited;

  ss &#x3C;&#x3C; <span class="hljs-string">"digraph G {\n"</span>;
  <span class="hljs-built_in">traverse_graphviz</span>(*<span class="hljs-keyword">this</span>, visited, ss);
  ss &#x3C;&#x3C; <span class="hljs-string">"}\n"</span>;

  <span class="hljs-keyword">return</span> ss.<span class="hljs-built_in">str</span>();
}
</code></pre>
<pre><code class="hljs language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&#x3C;iostream></span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"value.h"</span></span>

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-function">Value <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2.0</span>)</span></span>;
  <span class="hljs-function">Value <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">-3.0</span>)</span></span>;
  <span class="hljs-function">Value <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">10.0</span>)</span></span>;
  Value d = a * b + c;
  std::cout &#x3C;&#x3C; d.<span class="hljs-built_in">to_graphviz</span>() &#x3C;&#x3C; std::endl;
}
</code></pre>
<p>Output:</p>
<p><img src="/cpp_grad_graph.png" alt="graph output from graphviz"></p>
<h3>Conclusions</h3>
<p>Maybe C++ is not really the best way to do these things. Writing code manually is slow and inefficient. GPT-4 is way too cool. It's probably time to learn PyTorch now.</p></div></div></div></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note_id":"machine learning__cpp-grad","noteData":{"metadata":{"title":"cpp-grad","date":"2023-04-17"},"content":"\u003chr\u003e\n\u003ch1\u003eReimplementing Micrograd in C++\u003c/h1\u003e\n\u003ch2\u003ePart 1 â€“ An unexpected error\u003c/h2\u003e\n\u003cp\u003eI was watching \u003ca href=\"https://www.youtube.com/watch?v=VMj-3S1tku0\"\u003eAndrej Karpathy's lecture on micrograd\u003c/a\u003e and decided to implement a micrograd-like library in C++. It feels only natural to implement it in C++ because the operations will be more efficient in C++. Also I'd get a chance to write some more C++ code and use some more object oriented features of C++ like operator overloading.\u003c/p\u003e\n\u003cp\u003eSo at first I naively started implementing micrograd, basically doing what Andrej was doing in Python and mentally translating it into C++ code. However at one point I got stuck on an interesting error.\u003c/p\u003e\n\u003ch3\u003eThe code\u003c/h3\u003e\n\u003cp\u003eThe initial part of micrograd is basically about creating an expression graph of variables and operators and using that expression graph to then traverse backward and update the gradients. I had basically created the expression graph and was trying to print it out while traversing it recursively that I noticed a problem.\u003c/p\u003e\n\u003cp\u003eHere's the code I had till then:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emain.cpp\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;iostream\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"engine.h\"\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-function\"\u003eValue \u003cspan class=\"hljs-title\"\u003ea\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e;\n  \u003cspan class=\"hljs-function\"\u003eValue \u003cspan class=\"hljs-title\"\u003eb\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-number\"\u003e-3.0\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e;\n  \u003cspan class=\"hljs-function\"\u003eValue \u003cspan class=\"hljs-title\"\u003ec\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-number\"\u003e10.0\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e;\n  Value d = a * b + c;\n  std::cout \u0026#x3C;\u0026#x3C; d.\u003cspan class=\"hljs-built_in\"\u003edbg\u003c/span\u003e() \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eengine.h\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;iostream\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;ostream\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;set\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e {\n \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e:\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexplicit\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eValue\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e data)\u003c/span\u003e : data_(data) {\u003c/span\u003e}\n\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexplicit\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eValue\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e data, std::set\u0026#x3C;\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value *\u003e prev, \u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e op)\u003c/span\u003e\n      : data_(data), prev_(prev), op_(op){\u003c/span\u003e};\n\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003edata\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e \u003c/span\u003e{ \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e data_; }\n\n  \u003cspan class=\"hljs-keyword\"\u003efriend\u003c/span\u003e std::ostream \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eoperator\u003c/span\u003e\u0026#x3C;\u0026#x3C;(std::ostream \u0026#x26;out, Value v);\n\n  Value \u003cspan class=\"hljs-keyword\"\u003eoperator\u003c/span\u003e+(\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value \u0026#x26;other) \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e;\n  Value \u003cspan class=\"hljs-keyword\"\u003eoperator\u003c/span\u003e*(\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value \u0026#x26;other) \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-function\"\u003estd::string \u003cspan class=\"hljs-title\"\u003edbg\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e\u003c/span\u003e;\n\n \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e:\n  \u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e data_ = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  std::set\u0026#x3C;\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value *\u003e prev_;\n  \u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e op_ = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eengine.cpp\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"engine.h\"\u003c/span\u003e\u003c/span\u003e\n\nstd::ostream \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eoperator\u003c/span\u003e\u0026#x3C;\u0026#x3C;(std::ostream \u0026#x26;out, Value v) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e out \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"Value(\"\u003c/span\u003e \u0026#x3C;\u0026#x3C; v.\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e() \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\")\"\u003c/span\u003e;\n}\n\nValue Value::\u003cspan class=\"hljs-keyword\"\u003eoperator\u003c/span\u003e+(\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value \u0026#x26;other) \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e {\n  Value out = \u003cspan class=\"hljs-built_in\"\u003eValue\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e() + other.\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e(), {\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, \u0026#x26;other}, \u003cspan class=\"hljs-string\"\u003e'*'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e out;\n}\n\nValue Value::\u003cspan class=\"hljs-keyword\"\u003eoperator\u003c/span\u003e*(\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value \u0026#x26;other) \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e {\n  Value out = \u003cspan class=\"hljs-built_in\"\u003eValue\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e() * other.\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e(), {\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, \u0026#x26;other}, \u003cspan class=\"hljs-string\"\u003e'*'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e out;\n}\n\n\u003cspan class=\"hljs-function\"\u003estd::string \u003cspan class=\"hljs-title\"\u003eValue::dbg\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (op_) {\n    std::string children_dbg;\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value *v : prev_) {\n      children_dbg += v-\u003e\u003cspan class=\"hljs-built_in\"\u003edbg\u003c/span\u003e() + \u003cspan class=\"hljs-string\"\u003e\", \"\u003c/span\u003e;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Value(data=\"\u003c/span\u003e + std::\u003cspan class=\"hljs-built_in\"\u003eto_string\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e()) + \u003cspan class=\"hljs-string\"\u003e\",op=\"\u003c/span\u003e + op_ +\n           \u003cspan class=\"hljs-string\"\u003e\",prev={\"\u003c/span\u003e + children_dbg + \u003cspan class=\"hljs-string\"\u003e\"})\"\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Value(data=\"\u003c/span\u003e + std::\u003cspan class=\"hljs-built_in\"\u003eto_string\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e()) + \u003cspan class=\"hljs-string\"\u003e\")\"\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(Note that Andrej did not define a \u003ccode\u003edbg\u003c/code\u003e function like me, instead he had defined a couple of functions to print out the graph in a graphviz format which also renders it in the jupyter notebook, but since I was doing it in C++, the \u003ccode\u003edbg\u003c/code\u003e function would have to do for now.)\u003c/p\u003e\n\u003ch3\u003eThe problem:\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sh\"\u003e@krkartikay âžœ /workspaces/cpp-grad (main) $ make \u0026#x26;\u0026#x26; ./main\ng++ main.cpp engine.cpp nn.cpp -o main\nSegmentation fault (core dumped)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo, can you figure out what went wrong? There's only one place where the crash could happen, when we call \u003ccode\u003ev-\u003edbg()\u003c/code\u003e and dereference the pointer \u003ccode\u003ev\u003c/code\u003e, because there is no other place where we're dereferencing a pointer. But why did it crash? It looks like we're initialising the pointers with the correct values, and there shouldn't be any \u003ccode\u003enullptr\u003c/code\u003es anywhere. So what's the problem then?\u003c/p\u003e\n\u003cp\u003eHere's a hint, the code worked when I changed the following lines in \u003ccode\u003emain.cpp\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e  Value d = a * b + c;\n  std::cout \u0026#x3C;\u0026#x3C; d.\u003cspan class=\"hljs-built_in\"\u003edbg\u003c/span\u003e() \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eto this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e  Value d = a * b;\n  Value e = d + c;\n  std::cout \u0026#x3C;\u0026#x3C; e.\u003cspan class=\"hljs-built_in\"\u003edbg\u003c/span\u003e() \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd this was the output then:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@krkartikay âžœ /workspaces/cpp-grad (main) $ make \u0026#x26;\u0026#x26; ./main\ng++ main.cpp engine.cpp nn.cpp -o main\nValue(data=4.000000,op=*,prev={Value(data=10.000000), Value(data=-6.000000,op=*,prev={Value(data=2.000000), Value(data=-3.000000), }), })\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo here's basically what's happening. When we are evaluating \u003ccode\u003ea * b + c\u003c/code\u003e, \u003ccode\u003e(a * b)\u003c/code\u003e first creates a temporary object that gets added with \u003ccode\u003ec\u003c/code\u003e and the node \u003ccode\u003ed\u003c/code\u003e (the output node) contains a pointer to the temporary object \u003ccode\u003e(a * b)\u003c/code\u003e. This temporary object gets destructed as soon as the expression finishes evaluating and we reach the next line (\u003ccode\u003ed.dbg()\u003c/code\u003e). So when we call \u003ccode\u003ev-\u003edbg()\u003c/code\u003e on this node, the \u003ccode\u003ev\u003c/code\u003e pointer points to a destructed object. This is a problem that wouldn't happen in Python because all objects are created on the heap and the garbage collector takes care of reference counting and doesn't delete this object as it still has one reference.\u003c/p\u003e\n\u003ch3\u003eThe solution\u003c/h3\u003e\n\u003cp\u003eSo how do we solve this problem? I got stuck on this problem because while I understood what's going wrong, the best solution wasn't immediately obvious to me. However after some thinking I decided that maybe doing something like what Python does is the best approach. We can let the Value class be a wrapper for a smart-pointer like object, which creates the actual object on the heap and does the reference counting, while it also has the right operator-overloads for writing expressions like this.\u003c/p\u003e\n\u003cp\u003eI wanted to write code to fix this problem, but then I thought it was too boring. Let's ask ChatGPT instead? I first wanted to see if GPT-4 understands the problem. I gave it all the above text up to the point where I ask, \"So, can you figure out what went wrong?\".\u003c/p\u003e\n\u003cp\u003eHere's what it gave me:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIt looks like you are running into a segmentation fault while trying to print the expression graph. The segmentation fault usually occurs when a program tries to access memory that it is not allowed to. In your case, it seems to be related to the recursive traversal of the expression graph when calling the \u003ccode\u003edbg()\u003c/code\u003e function.\u003c/p\u003e\n\u003cp\u003eAfter analyzing your code, I have noticed an issue in the Value::operator+ function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003eValue Value::\u003cspan class=\"hljs-keyword\"\u003eoperator\u003c/span\u003e+(\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value \u0026#x26;other) \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e {\n  Value out = \u003cspan class=\"hljs-built_in\"\u003eValue\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e() + other.\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e(), {\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, \u0026#x26;other}, \u003cspan class=\"hljs-string\"\u003e'*'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e out;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere, you are initializing out with an \u003ccode\u003eop_\u003c/code\u003e value of '*', which should be '+' instead, as this is the addition operator. However, this is not the primary cause of the segmentation fault.\u003c/p\u003e\n\u003cp\u003eThe main issue lies in the fact that you are storing pointers to local Value objects in the \u003ccode\u003eprev_\u003c/code\u003e set. When you create a new Value object inside the \u003ccode\u003eoperator+\u003c/code\u003e and \u003ccode\u003eoperator*\u003c/code\u003e functions, these objects have local scope and will be destroyed once the function returns. As a result, the pointers stored in the \u003ccode\u003eprev_\u003c/code\u003e set of the parent Value object will become dangling pointers, pointing to invalid memory locations.\u003c/p\u003e\n\u003cp\u003eTo fix the issue, you need to manage the memory for the Value objects more carefully. One way to do this is to use dynamic memory allocation with smart pointers. You can use \u003ccode\u003estd::shared_ptr\u003c/code\u003e to manage the memory of Value objects, which will automatically deallocate the memory when there are no more references to the object.\u003c/p\u003e\n\u003cp\u003eHere's an updated version of your code using \u003ccode\u003estd::shared_ptr\u003c/code\u003e: ...\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIt did find out the issue and fix it! That too in the first try. I'm impressed! And it even found an unrelated mistake. I bet you didn't see that either. The solution it suggested was something like this, to modify the Value class to hold a set of \u003ccode\u003eshared_ptr\u003c/code\u003e's instead:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003estd::set\u0026#x3C;std::shared_ptr\u0026#x3C;\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value\u003e\u003e prev_;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand to define the operators like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003eValue Value::\u003cspan class=\"hljs-keyword\"\u003eoperator\u003c/span\u003e+(\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value \u0026#x26;other) \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e {\n  Value out = \u003cspan class=\"hljs-built_in\"\u003eValue\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e() + other.\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e(),\n                    {std::\u003cspan class=\"hljs-built_in\"\u003emake_shared\u003c/span\u003e\u0026#x3C;Value\u003e(*\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e),\n                     std::\u003cspan class=\"hljs-built_in\"\u003emake_shared\u003c/span\u003e\u0026#x3C;Value\u003e(other)}, \u003cspan class=\"hljs-string\"\u003e'+'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e out;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHowever I was worried with this solution that it may create duplicate nodes and not understand that some nodes are shared. I asked it to explain the difference between \u003ccode\u003eshared_ptr\u003c/code\u003e and \u003ccode\u003eunique_ptr\u003c/code\u003e and this is what it told me:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003estd::shared_ptr\u003c/code\u003e is a smart pointer provided by the C++ Standard Library that manages shared ownership of a dynamically allocated object. It keeps track of the number of \u003ccode\u003eshared_ptr\u003c/code\u003e instances referring to the same object, using reference counting. When the last \u003ccode\u003eshared_ptr\u003c/code\u003e that owns the object is destroyed or reset, the object is automatically deleted.\u003c/p\u003e\n\u003cp\u003eIn the updated program, \u003ccode\u003estd::shared_ptr\u003c/code\u003e ensures that the temporary \u003ccode\u003eValue\u003c/code\u003e objects are not deleted prematurely by managing their lifetime based on reference counts. When you create a \u003ccode\u003eshared_ptr\u003c/code\u003e for a Value object inside the operator+ and operator* functions, the reference count for the object is increased. These \u003ccode\u003eshared_ptr\u003c/code\u003e instances are then stored in the \u003ccode\u003eprev_\u003c/code\u003e set of the parent Value object. As long as there is at least one \u003ccode\u003eshared_ptr\u003c/code\u003e referring to the object, it won't be deleted.\u003c/p\u003e\n\u003cp\u003eWhen the parent Value object is destroyed or goes out of scope, the \u003ccode\u003eshared_ptr\u003c/code\u003e instances in the \u003ccode\u003eprev_\u003c/code\u003e set are also destroyed, which in turn decreases the reference count for the child Value objects. If the reference count reaches zero, the object is deleted automatically, ensuring proper memory management.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::unique_ptr\u003c/code\u003e is another smart pointer provided by the C++ Standard Library that manages the exclusive ownership of a dynamically allocated object. Unlike \u003ccode\u003estd::shared_ptr\u003c/code\u003e, it doesn't use reference counting, as it is designed to have only one owner at a time. When a unique_ptr is destroyed or reset, the object it owns is automatically deleted.\u003c/p\u003e\n\u003cp\u003eThe main differences between \u003ccode\u003estd::shared_ptr\u003c/code\u003e and \u003ccode\u003estd::unique_ptr\u003c/code\u003e are:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eOwnership: \u003ccode\u003estd::shared_ptr\u003c/code\u003e allows shared ownership, meaning multiple \u003ccode\u003eshared_ptr\u003c/code\u003e instances can own the same object. In contrast, \u003ccode\u003estd::unique_ptr\u003c/code\u003e enforces exclusive ownership, with only one \u003ccode\u003eunique_ptr\u003c/code\u003e owning the object at any given time.\u003c/li\u003e\n\u003cli\u003eReference counting: \u003ccode\u003estd::shared_ptr\u003c/code\u003e uses reference counting to keep track of the number of instances owning the same object. This adds some overhead compared to \u003ccode\u003estd::unique_ptr\u003c/code\u003e, which doesn't use reference counting.\u003c/li\u003e\n\u003cli\u003eCopying and assignment: \u003ccode\u003estd::shared_ptr\u003c/code\u003e can be copied and assigned to other \u003ccode\u003eshared_ptr\u003c/code\u003e instances, which increases the reference count. \u003ccode\u003estd::unique_ptr\u003c/code\u003e cannot be copied, but it can be moved using \u003ccode\u003estd::move\u003c/code\u003e, transferring ownership to another \u003ccode\u003eunique_ptr\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eIn the provided example, \u003ccode\u003estd::shared_ptr\u003c/code\u003e is more suitable because the expression graph requires shared ownership of the Value objects, and the lifetime of the objects needs to be managed based on reference counts. \u003ccode\u003estd::unique_ptr\u003c/code\u003e wouldn't be appropriate in this case, as it enforces exclusive ownership and doesn't support reference counting.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eI also asked it about my wrapper solution, and here's what it said:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWould it be better if instead of modifying the Value class to hold shared_ptrs in the \u003ccode\u003eprev_\u003c/code\u003e set, I create a new set of nodes elsewhere and let the Value class be a wrapper for a \u003ccode\u003eshared_ptr\u003c/code\u003e pointing to a \u003ccode\u003eValueNode\u003c/code\u003e in the set?\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eYes, that could be a good alternative design. By creating a separate set of nodes elsewhere and making the Value class a wrapper for a shared_ptr pointing to a ValueNode in the set, you can achieve the desired behavior while keeping the Value class simpler and more focused on its purpose.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHere's a possible implementation of this design: ...\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eI also tried asking it for various other modifications like adding a tagging functionality etc, and it did all of it perfectly.\nThis is the final code I got, written entirely* by GPT-4:\u003c/p\u003e\n\u003cp\u003e[* Of course the GPT-4 output did not compile directly. It even had a couple of minor syntax errors. But I only had to change a few lines to fix it, it had gotten very close to the solution. But then I wouldn't expect even my own code to compile on first try.]\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emain.cpp\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;iostream\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"value.h\"\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-function\"\u003eValue \u003cspan class=\"hljs-title\"\u003ea\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e;\n  Value b = a; \u003cspan class=\"hljs-comment\"\u003e// b shares the same underlying ValueNode as a\u003c/span\u003e\n  Value c = b * a;\n  std::cout \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"a: \"\u003c/span\u003e \u0026#x3C;\u0026#x3C; a.\u003cspan class=\"hljs-built_in\"\u003edbg\u003c/span\u003e() \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;\n  std::cout \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"b: \"\u003c/span\u003e \u0026#x3C;\u0026#x3C; b.\u003cspan class=\"hljs-built_in\"\u003edbg\u003c/span\u003e() \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;\n  std::cout \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"c: \"\u003c/span\u003e \u0026#x3C;\u0026#x3C; c.\u003cspan class=\"hljs-built_in\"\u003edbg\u003c/span\u003e() \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-function\"\u003eValue \u003cspan class=\"hljs-title\"\u003ed\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-number\"\u003e3.0\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e;\n  Value e = d * d;\n  std::cout \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"d: \"\u003c/span\u003e \u0026#x3C;\u0026#x3C; d.\u003cspan class=\"hljs-built_in\"\u003edbg\u003c/span\u003e() \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;\n  std::cout \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"e: \"\u003c/span\u003e \u0026#x3C;\u0026#x3C; e.\u003cspan class=\"hljs-built_in\"\u003edbg\u003c/span\u003e() \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;\n  \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003evalue.h\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003epragma\u003c/span\u003e once\u003c/span\u003e\n\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;memory\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"value_node.h\"\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e {\n \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e:\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexplicit\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eValue\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e data)\u003c/span\u003e\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003edata\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003efriend\u003c/span\u003e std::ostream \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eoperator\u003c/span\u003e\u0026#x3C;\u0026#x3C;(std::ostream \u0026#x26;out, \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value \u0026#x26;v);\n\n  Value \u003cspan class=\"hljs-keyword\"\u003eoperator\u003c/span\u003e+(\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value \u0026#x26;other) \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e;\n  Value \u003cspan class=\"hljs-keyword\"\u003eoperator\u003c/span\u003e*(\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value \u0026#x26;other) \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-function\"\u003estd::string \u003cspan class=\"hljs-title\"\u003edbg\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e\u003c/span\u003e;\n\n \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e:\n  \u003cspan class=\"hljs-built_in\"\u003eValue\u003c/span\u003e();\n  std::shared_ptr\u0026#x3C;ValueNode\u003e node_;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003evalue.cpp\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"value.h\"\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;set\u003e\u003c/span\u003e\u003c/span\u003e\n\nValue::\u003cspan class=\"hljs-built_in\"\u003eValue\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e data)\n    : \u003cspan class=\"hljs-built_in\"\u003enode_\u003c/span\u003e(std::\u003cspan class=\"hljs-built_in\"\u003emake_shared\u003c/span\u003e\u0026#x3C;ValueNode\u003e(data)) {}\n\nValue::\u003cspan class=\"hljs-built_in\"\u003eValue\u003c/span\u003e() {}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eValue::data\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e \u003c/span\u003e{ \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e node_-\u003e\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e(); }\n\nstd::ostream \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eoperator\u003c/span\u003e\u0026#x3C;\u0026#x3C;(std::ostream \u0026#x26;out, \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value \u0026#x26;v) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e out \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"Value(\"\u003c/span\u003e \u0026#x3C;\u0026#x3C; v.\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e() \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\")\"\u003c/span\u003e;\n}\n\nValue Value::\u003cspan class=\"hljs-keyword\"\u003eoperator\u003c/span\u003e+(\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value \u0026#x26;other) \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eauto\u003c/span\u003e node = std::\u003cspan class=\"hljs-built_in\"\u003emake_shared\u003c/span\u003e\u0026#x3C;ValueNode\u003e(\n      \u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e() + other.\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e(),\n      std::set\u0026#x3C;std::shared_ptr\u0026#x3C;ValueNode\u003e\u003e({node_, other.node_}),\n      \u003cspan class=\"hljs-string\"\u003e'+'\u003c/span\u003e);\n  Value out;\n  out.node_ = node;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e out;\n}\n\nValue Value::\u003cspan class=\"hljs-keyword\"\u003eoperator\u003c/span\u003e*(\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value \u0026#x26;other) \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eauto\u003c/span\u003e node = std::\u003cspan class=\"hljs-built_in\"\u003emake_shared\u003c/span\u003e\u0026#x3C;ValueNode\u003e(\n      \u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e() * other.\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e(),\n      std::set\u0026#x3C;std::shared_ptr\u0026#x3C;ValueNode\u003e\u003e({node_, other.node_}),\n      \u003cspan class=\"hljs-string\"\u003e'*'\u003c/span\u003e);\n  Value out;\n  out.node_ = node;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e out;\n}\n\n\u003cspan class=\"hljs-function\"\u003estd::string \u003cspan class=\"hljs-title\"\u003eValue::dbg\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e \u003c/span\u003e{ \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e node_-\u003e\u003cspan class=\"hljs-built_in\"\u003edbg\u003c/span\u003e(); }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003evalue_node.h\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003epragma\u003c/span\u003e once\u003c/span\u003e\n\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;iostream\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;memory\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;set\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;string\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eValueNode\u003c/span\u003e {\n \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e:\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexplicit\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eValueNode\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e data)\u003c/span\u003e\u003c/span\u003e;\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexplicit\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eValueNode\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e data,\n                     std::set\u0026#x3C;std::shared_ptr\u0026#x3C;ValueNode\u003e\u003e prev,\n                     \u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e op)\u003c/span\u003e\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003edata\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e\u003c/span\u003e;\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eid\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-function\"\u003estd::string \u003cspan class=\"hljs-title\"\u003edbg\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e\u003c/span\u003e;\n\n \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e:\n  \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e id_;\n  \u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e data_ = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  std::set\u0026#x3C;std::shared_ptr\u0026#x3C;ValueNode\u003e\u003e prev_;\n  \u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e op_ = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-type\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e next_id_;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003evalue_node.cpp\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"value_node.h\"\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e ValueNode::next_id_ = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\nValueNode::\u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e data) : \u003cspan class=\"hljs-built_in\"\u003eid_\u003c/span\u003e(next_id_++), \u003cspan class=\"hljs-built_in\"\u003edata_\u003c/span\u003e(data) {}\n\nValueNode::\u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e data,\n                     std::set\u0026#x3C;std::shared_ptr\u0026#x3C;ValueNode\u003e\u003e prev,\n                     \u003cspan class=\"hljs-type\"\u003echar\u003c/span\u003e op)\n    : \u003cspan class=\"hljs-built_in\"\u003eid_\u003c/span\u003e(next_id_++), \u003cspan class=\"hljs-built_in\"\u003edata_\u003c/span\u003e(data), \u003cspan class=\"hljs-built_in\"\u003eprev_\u003c/span\u003e(prev), \u003cspan class=\"hljs-built_in\"\u003eop_\u003c/span\u003e(op) {}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eValueNode::data\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e \u003c/span\u003e{ \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e data_; }\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eValueNode::id\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e \u003c/span\u003e{ \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e id_; }\n\n\u003cspan class=\"hljs-function\"\u003estd::string \u003cspan class=\"hljs-title\"\u003eValueNode::dbg\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (op_) {\n    std::string children_dbg;\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eauto\u003c/span\u003e \u0026#x26;v : prev_) {\n      children_dbg += v-\u003e\u003cspan class=\"hljs-built_in\"\u003edbg\u003c/span\u003e() + \u003cspan class=\"hljs-string\"\u003e\", \"\u003c/span\u003e;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ValueNode(id=\"\u003c/span\u003e + std::\u003cspan class=\"hljs-built_in\"\u003eto_string\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eid\u003c/span\u003e()) +\n           \u003cspan class=\"hljs-string\"\u003e\",data=\"\u003c/span\u003e + std::\u003cspan class=\"hljs-built_in\"\u003eto_string\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e()) + \u003cspan class=\"hljs-string\"\u003e\",op=\"\u003c/span\u003e + op_ +\n           \u003cspan class=\"hljs-string\"\u003e\",prev={\"\u003c/span\u003e + children_dbg + \u003cspan class=\"hljs-string\"\u003e\"})\"\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ValueNode(id=\"\u003c/span\u003e + std::\u003cspan class=\"hljs-built_in\"\u003eto_string\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eid\u003c/span\u003e()) +\n         \u003cspan class=\"hljs-string\"\u003e\",data=\"\u003c/span\u003e + std::\u003cspan class=\"hljs-built_in\"\u003eto_string\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003edata\u003c/span\u003e()) + \u003cspan class=\"hljs-string\"\u003e\")\"\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003eGPT-4's predicted output:\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003ea: \u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,data=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\nb: \u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,data=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\nc: \u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,data=\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,op=*,prev={\u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,data=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e), \u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,data=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)})\nd: \u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,data=\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)\ne: \u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,data=\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e,op=*,prev={\u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,data=\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e), \u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,data=\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)})\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003eActual Output:\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003ea: \u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,data=\u003cspan class=\"hljs-number\"\u003e2.000000\u003c/span\u003e)\nb: \u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,data=\u003cspan class=\"hljs-number\"\u003e2.000000\u003c/span\u003e)\nc: \u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,data=\u003cspan class=\"hljs-number\"\u003e4.000000\u003c/span\u003e,op=*,prev={\u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,data=\u003cspan class=\"hljs-number\"\u003e2.000000\u003c/span\u003e), })\nd: \u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,data=\u003cspan class=\"hljs-number\"\u003e3.000000\u003c/span\u003e)\ne: \u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,data=\u003cspan class=\"hljs-number\"\u003e9.000000\u003c/span\u003e,op=*,prev={\u003cspan class=\"hljs-built_in\"\u003eValueNode\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,data=\u003cspan class=\"hljs-number\"\u003e3.000000\u003c/span\u003e), })\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eBonus?\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Add these includes at the beginning of the file\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;sstream\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;unordered_set\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// Add this function declaration in the `Value` class\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003estd::string \u003cspan class=\"hljs-title\"\u003eto_graphviz\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Helper function for the recursive traversal\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003etraverse_graphviz\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value \u0026#x26;v, std::unordered_set\u0026#x3C;\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value *\u003e \u0026#x26;visited, std::stringstream \u0026#x26;ss)\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (visited.\u003cspan class=\"hljs-built_in\"\u003ecount\u003c/span\u003e(\u0026#x26;v) == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n    visited.\u003cspan class=\"hljs-built_in\"\u003einsert\u003c/span\u003e(\u0026#x26;v);\n\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eauto\u003c/span\u003e \u0026#x26;prev : v.prev_) {\n      ss \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"\\\"\"\u003c/span\u003e \u0026#x3C;\u0026#x3C; prev-\u003eid_ \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"\\\" -\u003e \\\"\"\u003c/span\u003e \u0026#x3C;\u0026#x3C; v.id_ \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"\\\";\\n\"\u003c/span\u003e;\n      \u003cspan class=\"hljs-built_in\"\u003etraverse_graphviz\u003c/span\u003e(*prev, visited, ss);\n    }\n\n    ss \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"\\\"\"\u003c/span\u003e \u0026#x3C;\u0026#x3C; v.id_ \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"\\\" [label=\\\"Value(id=\"\u003c/span\u003e \u0026#x3C;\u0026#x3C; v.id_ \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\", data=\"\u003c/span\u003e \u0026#x3C;\u0026#x3C; v.data_ \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\", op=\"\u003c/span\u003e \u0026#x3C;\u0026#x3C; (v.op_ ? v.op_ : \u003cspan class=\"hljs-string\"\u003e' '\u003c/span\u003e) \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\")\\\"];\\n\"\u003c/span\u003e;\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// to_graphviz function implementation\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003estd::string \u003cspan class=\"hljs-title\"\u003eValue::to_graphviz\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e \u003c/span\u003e{\n  std::stringstream ss;\n  std::unordered_set\u0026#x3C;\u003cspan class=\"hljs-type\"\u003econst\u003c/span\u003e Value *\u003e visited;\n\n  ss \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"digraph G {\\n\"\u003c/span\u003e;\n  \u003cspan class=\"hljs-built_in\"\u003etraverse_graphviz\u003c/span\u003e(*\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e, visited, ss);\n  ss \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"}\\n\"\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e ss.\u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x3C;iostream\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#\u003cspan class=\"hljs-keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"value.h\"\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-function\"\u003eValue \u003cspan class=\"hljs-title\"\u003ea\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e;\n  \u003cspan class=\"hljs-function\"\u003eValue \u003cspan class=\"hljs-title\"\u003eb\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-number\"\u003e-3.0\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e;\n  \u003cspan class=\"hljs-function\"\u003eValue \u003cspan class=\"hljs-title\"\u003ec\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-number\"\u003e10.0\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e;\n  Value d = a * b + c;\n  std::cout \u0026#x3C;\u0026#x3C; d.\u003cspan class=\"hljs-built_in\"\u003eto_graphviz\u003c/span\u003e() \u0026#x3C;\u0026#x3C; std::endl;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOutput:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/cpp_grad_graph.png\" alt=\"graph output from graphviz\"\u003e\u003c/p\u003e\n\u003ch3\u003eConclusions\u003c/h3\u003e\n\u003cp\u003eMaybe C++ is not really the best way to do these things. Writing code manually is slow and inefficient. GPT-4 is way too cool. It's probably time to learn PyTorch now.\u003c/p\u003e"},"allNotesIndex":{"base_name":"notes","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes","notes_data":[{"id":"quotes","metadata":{"title":"Quotes","date":"2023-03-21"}}],"directories":[{"base_name":"book notes","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/book notes","notes_data":[{"id":"dokkodo","metadata":{"title":"Dokkodo","date":"2023-03-23"}},{"id":"if","metadata":{"title":"\"If\"","date":"2023-03-27"}},{"id":"worry","metadata":{"title":"Worry","date":"2023-03-29"}}],"directories":[{"base_name":"the bhagvad gita","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/book notes/the bhagvad gita","notes_data":[{"id":"chapter_1","metadata":{"title":"Chapter 1","date":"2023-04-06"}},{"id":"chapter_2","metadata":{"title":"Chapter 2","date":"2023-04-08"}},{"id":"index","metadata":{"title":"The Bhagvad Gita","date":"2023-04-06"}}],"directories":[]}]},{"base_name":"economics","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/economics","notes_data":[],"directories":[{"base_name":"microeconomics","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/economics/microeconomics","notes_data":[{"id":"index","metadata":{"title":"Principles of Microeconomics","date":"2023-03-23"}},{"id":"lecture_1","metadata":{"title":"Lecture 1","date":"2023-03-23"}},{"id":"lecture_2","metadata":{"title":"Lecture 2","date":"2023-03-23"}},{"id":"lecture_3","metadata":{"title":"Lecture 3","date":"2023-03-23"}},{"id":"lecture_4","metadata":{"title":"Lecture 4","date":"2023-04-01"}},{"id":"lecture_5","metadata":{"title":"Lecture 5","date":"2023-04-01"}},{"id":"lecture_6","metadata":{"title":"Lecture 6","date":"2023-04-01"}}],"directories":[]}]},{"base_name":"machine learning","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/machine learning","notes_data":[{"id":"cpp-grad","metadata":{"title":"cpp-grad","date":"2023-04-17"}},{"id":"karpathy-lectures","metadata":{"title":"Andrey Karpathy's Lectures","date":"2023-05-14"}},{"id":"study-plan","metadata":{"title":"ML Study plan","date":"2024-01-14"}}],"directories":[{"base_name":"alpha zero","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/machine learning/alpha zero","notes_data":[{"id":"1-the-start","metadata":{"title":"1. The Start","date":"2024-01-14"}},{"id":"2-initial-plan","metadata":{"title":"2. Initial plan","date":"2024-01-14"}},{"id":"3-supervised-learning","metadata":{"title":"3. Supervised Learning","date":"2024-01-15"}},{"id":"4-experimentation","metadata":{"title":"4. Experimentation Framework","date":"2024-01-20"}},{"id":"5-visualization","metadata":{"title":"5. Visualization","date":"2024-01-21"}},{"id":"_notes","metadata":{"title":"_notes"}}],"directories":[]}]}]}},"__N_SSG":true},"page":"/notes/[note_id]","query":{"note_id":"machine learning__cpp-grad"},"buildId":"0cQi27foYwZlvrxIm4tXk","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>