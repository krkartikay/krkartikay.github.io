{"pageProps":{"note_id":"machine learning__alpha zero__3-supervised-learning","noteData":{"metadata":{"title":"3. Supervised Learning","date":"2024-01-15"},"content":"<h3>First update!</h3>\n<p>I've got supervised learning to kinda work!</p>\n<p>I've been able to generate a dataset consisting of lots of random positions and\nthe allowed moves in all those positions. Then I've been able to read that data\nand train neural networks on it which learn the rules of chess reasonably well.</p>\n<p>I'm implementing it again (cleanly) <a href=\"https://github.com/krkartikay/chess-sl\">in this repo</a>\nand also documenting whatever I'm doing here.</p>\n<h3>Generating the dataset</h3>\n<p>First we will need to generate the dataset consisting of randomly generated\npositions and the allowed move in each position. This can be done using the\n<code>chess</code> python library.</p>\n<p><a href=\"https://github.com/krkartikay/chess-sl/blob/main/gen_moves.py\">gen_moves.py</a></p>\n<pre><code class=\"hljs language-py\"><span class=\"hljs-keyword\">import</span> chess\n<span class=\"hljs-keyword\">import</span> random\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">generate_random_game</span>():\n    board = chess.Board()\n    history = []\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">not</span> board.is_game_over():\n        <span class=\"hljs-comment\"># print(board)</span>\n        valid_moves = <span class=\"hljs-built_in\">list</span>(board.generate_legal_moves())\n        <span class=\"hljs-comment\"># print(valid_moves)</span>\n        random_move = random.choice(valid_moves)\n        history.append((board, valid_moves))\n        board.push(random_move)\n    <span class=\"hljs-keyword\">return</span> history\n</code></pre>\n<p>Then we need to store the generated data. Now we could serialise it into any\nformat. Games are generally stored in PGN format and we could find some format\nfor our moves too but since we're going to train neural networks using this data\nso it may be best to convert these to tensors already and store them in a tensor\nformat.</p>\n<p>So far the code is pretty fast, taking only ~2s to generate 100 games.</p>\n<pre><code>$ time python gen_moves.py \nGenerating game 1.\nGenerating game 2.\nGenerating game 3.\n...\nGenerating game 100.\nDone! Generated 100 games!\n\nreal    0m2.396s\nuser    0m2.282s\nsys     0m0.111s\n</code></pre>\n<h3>Converting to tensors</h3>\n<p>There are many possible ways we could do this, but I'm going to encode the 6\npiece types (Pawn, Rook, Knight, etc.) into different planes into a tensor.\nI'm going to use +1 for the white pieces and -1 for the black pieces.\nI'm also going to add another plane which is entirely +1 or -1 denoting whose\nturn it is currently.</p>\n<p>Here's the code:</p>\n<p><a href=\"https://github.com/krkartikay/chess-sl/blob/main/chess_utils.py\">chess_utils.py</a></p>\n<pre><code class=\"hljs language-py\"><span class=\"hljs-keyword\">import</span> chess\n<span class=\"hljs-keyword\">import</span> torch\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">board_to_tensor</span>(<span class=\"hljs-params\">board: chess.Board</span>) -> torch.Tensor:\n    return_tensor = torch.zeros((<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">8</span>))\n    <span class=\"hljs-comment\"># Iterate over the 6 piece types and add them to the appropriate plane</span>\n    <span class=\"hljs-comment\"># in the return tensor.</span>\n    <span class=\"hljs-keyword\">for</span> layer <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">7</span>):\n        pt = chess.PieceType(layer)\n        <span class=\"hljs-comment\"># add +1 for all the white pieces and -1 for black pieces</span>\n        bitboard_white = board.pieces_mask(pt, chess.WHITE)\n        bitboard_black = board.pieces_mask(pt, chess.BLACK)\n        <span class=\"hljs-keyword\">for</span> sq <span class=\"hljs-keyword\">in</span> chess.SQUARES:\n            <span class=\"hljs-keyword\">if</span> bitboard_white &#x26; (<span class=\"hljs-number\">1</span> &#x3C;&#x3C; sq):\n                row, col = <span class=\"hljs-built_in\">divmod</span>(sq, <span class=\"hljs-number\">8</span>)\n                return_tensor[layer, row, col] += <span class=\"hljs-number\">1</span>\n            <span class=\"hljs-keyword\">if</span> bitboard_black &#x26; (<span class=\"hljs-number\">1</span> &#x3C;&#x3C; sq):\n                row, col = <span class=\"hljs-built_in\">divmod</span>(sq, <span class=\"hljs-number\">8</span>)\n                return_tensor[layer, row, col] -= <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-comment\"># fill in the last layer according with +/- 1 based on whose turn it is</span>\n        <span class=\"hljs-keyword\">if</span> board.turn == chess.WHITE:\n            return_tensor[<span class=\"hljs-number\">0</span>, :, :] += <span class=\"hljs-number\">1</span>\n        <span class=\"hljs-keyword\">else</span>:\n            return_tensor[<span class=\"hljs-number\">0</span>, :, :] -= <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">return</span> return_tensor\n</code></pre>\n<p>Simply calling this function in <code>main()</code> on every position we have so far\nincreases the running time of the script to around ~5-6 seconds.</p>\n<p>I'm also writing unit tests this time... it helped me catch a bug already!\n(Do you see what was wrong in the code above? Hehe...)</p>\n<p><a href=\"https://github.com/krkartikay/chess-sl/blob/main/chess_utils_test.py\">chess_utils_test.py</a></p>\n<pre><code class=\"hljs language-py\"><span class=\"hljs-keyword\">import</span> chess\n<span class=\"hljs-keyword\">import</span> chess_utils\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_board_to_tensor</span>():\n    board = chess.Board()\n    tensor = chess_utils.board_to_tensor(board)\n    <span class=\"hljs-built_in\">print</span>(tensor)\n\n    <span class=\"hljs-comment\"># tensor has correct shape</span>\n    <span class=\"hljs-keyword\">assert</span> tensor.size() == (<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">8</span>)\n\n    <span class=\"hljs-comment\"># first turn is white</span>\n    <span class=\"hljs-keyword\">assert</span> tensor[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>] == <span class=\"hljs-number\">1</span>\n\n    <span class=\"hljs-comment\"># board has equal number of pieces at the start</span>\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">7</span>):\n        <span class=\"hljs-keyword\">assert</span> tensor[i].<span class=\"hljs-built_in\">sum</span>() == <span class=\"hljs-number\">0</span>\n</code></pre>\n<pre><code>$ pytest\n=========================== test session starts ============================\nplatform linux -- Python 3.11.4, pytest-7.4.0, pluggy-1.0.0\nrootdir: /home/krkartikay/code/chess-sl\nplugins: hydra-core-1.3.2, anyio-3.7.1\ncollected 1 item                                                           \n\nchess_utils_test.py F                                                [100%]\n\n================================= FAILURES =================================\n___________________________ test_board_to_tensor ___________________________\n\n    def test_board_to_tensor():\n        board = chess.Board()\n        tensor = chess_utils.board_to_tensor(board)\n    \n        # tensor has correct shape\n        assert tensor.size() == (7, 8, 8)\n    \n        # first turn is white\n>       assert tensor[0, 0, 0] == 1\nE       assert tensor(6.) == 1\n\nchess_utils_test.py:13: AssertionError\n========================= short test summary info ==========================\nFAILED chess_utils_test.py::test_board_to_tensor - assert tensor(6.) == 1\n============================ 1 failed in 0.76s =============================\n</code></pre>\n<h3>Encoding moves</h3>\n<p>Another big decision to make here is how to encode and decode the moves.\nAs I discussed last time, certain encodings make it easier or harder for the\nneural net to learn.</p>\n<p>For now I'm going to use a kind of <code>(from sq, to sq)</code> encoding.</p>\n<p>Here are my conversion functions:</p>\n<p><a href=\"https://github.com/krkartikay/chess-sl/blob/main/chess_utils.py\">chess_utils.py</a></p>\n<pre><code class=\"hljs language-py\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">move_to_action</span>(<span class=\"hljs-params\">move: chess.Move</span>) -> <span class=\"hljs-built_in\">int</span>:\n    a = move.from_square\n    b = move.to_square\n    idx = (a * <span class=\"hljs-number\">64</span>) + b\n    <span class=\"hljs-keyword\">return</span> idx\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">action_to_move</span>(<span class=\"hljs-params\">action: <span class=\"hljs-built_in\">int</span>, board: chess.Board</span>) -> chess.Move:\n    a, b = <span class=\"hljs-built_in\">divmod</span>(action, <span class=\"hljs-number\">64</span>)\n    move = chess.Move(a, b)\n\n    <span class=\"hljs-comment\"># check for possible promotion</span>\n    <span class=\"hljs-keyword\">if</span> (chess.square_rank(b) == (<span class=\"hljs-number\">7</span> <span class=\"hljs-keyword\">if</span> board.turn == chess.WHITE <span class=\"hljs-keyword\">else</span> <span class=\"hljs-number\">0</span>)\n            <span class=\"hljs-keyword\">and</span> board.piece_type_at(a) == chess.PAWN):\n        move = chess.Move(a, b, chess.QUEEN)\n\n    <span class=\"hljs-keyword\">return</span> move\n</code></pre>\n<p>Tested these via round trip encoding-decoding unit tests. Promotion works but\nonly to queen. We're gonna be ignoring underpromotion for now. It'll complicate\nthe action space architecture.</p>\n<p>Okay, now we just convert all the games to tensors and save them to a file.</p>\n<pre><code class=\"hljs language-py\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">convert_to_tensors</span>(<span class=\"hljs-params\">\n        games: <span class=\"hljs-type\">List</span>[<span class=\"hljs-type\">Tuple</span>[chess.Board, <span class=\"hljs-type\">List</span>[chess.Move]]]</span>) -> torch.Tensor:\n    all_positions = []\n    all_valid_moves = []\n    <span class=\"hljs-keyword\">for</span> game <span class=\"hljs-keyword\">in</span> games:\n        <span class=\"hljs-keyword\">for</span> position, valid_moves <span class=\"hljs-keyword\">in</span> game:\n            board_tensor = board_to_tensor(position)\n            moves_tensor = moves_to_tensor(valid_moves)\n            all_positions.append(board_tensor)\n            all_valid_moves.append(moves_tensor)\n    positions = torch.stack(all_positions)\n    valid_moves = torch.stack(all_valid_moves)\n    <span class=\"hljs-keyword\">return</span> positions, valid_moves\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">save_to_file</span>(<span class=\"hljs-params\">positions, moves, filename=<span class=\"hljs-string\">'games.pth'</span></span>):\n    <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(filename, <span class=\"hljs-string\">'wb'</span>) <span class=\"hljs-keyword\">as</span> datafile:\n        torch.save({<span class=\"hljs-string\">\"positions\"</span>: positions, <span class=\"hljs-string\">\"moves\"</span>: moves}, datafile)\n</code></pre>\n<p>And it works.  (Link to code so far at <a href=\"https://github.com/krkartikay/chess-sl/tree/d5135642685c8b43e4ebd000319a94206cee2771\">commit <code>d513564</code></a>.)</p>\n<pre><code>$ time python gen_moves.py \nGenerating game 1.\nGenerating game 2.\nGenerating game 3.\n...\nGenerating game 100.\nDone! Generated 100 games!\nConverting data to tensors.\nSaving to output file.\n\nreal    0m5.955s\nuser    0m5.743s\nsys     0m0.190s\n</code></pre>\n<h3>Creating a neural net!</h3>\n<p>Let's start with the simplest possible network, that has inputs in the format\n<code>7x8x8</code> and outputs move probabilities in a vector of size <code>64x64</code>.</p>\n<p>We will have just one hidden layer of <code>N_HIDDEN</code> neurons in between the input and\noutput. The output will have a sigmoid activation applied on it, in order\nto give us numbers between 0 and 1 which can be interpreted as probability\nof a move.</p>\n<p>(We're doing per move probability here. it is also possible to use softmax for\ngetting a probability distribution over all possible moves, but that makes the\nlearning harder. So just doing per-move probability for now.)</p>\n<p><a href=\"https://github.com/krkartikay/chess-sl/blob/main/model.py\">model.py</a></p>\n<pre><code class=\"hljs language-py\"><span class=\"hljs-keyword\">import</span> torch\n<span class=\"hljs-keyword\">import</span> torch.nn <span class=\"hljs-keyword\">as</span> nn\n<span class=\"hljs-keyword\">import</span> torch.nn.functional <span class=\"hljs-keyword\">as</span> F\n\nN_HIDDEN = <span class=\"hljs-number\">64</span>*<span class=\"hljs-number\">64</span>\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ChessModel</span>(nn.Module):\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self</span>):\n        <span class=\"hljs-built_in\">super</span>(ChessModel, self).__init__()\n\n        self.hidden_layer = nn.Linear(<span class=\"hljs-number\">7</span>*<span class=\"hljs-number\">8</span>*<span class=\"hljs-number\">8</span>, N_HIDDEN)\n        self.output_layer = nn.Linear(N_HIDDEN, <span class=\"hljs-number\">64</span>*<span class=\"hljs-number\">64</span>)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">forward</span>(<span class=\"hljs-params\">self, x</span>):\n        <span class=\"hljs-comment\"># Flatten the tensor</span>\n        x = x.view(x.size(<span class=\"hljs-number\">0</span>), -<span class=\"hljs-number\">1</span>)\n        <span class=\"hljs-comment\"># Apply hidden layer</span>\n        x = self.hidden_layer(x)\n        x = F.relu(x)\n        <span class=\"hljs-comment\"># Output layer</span>\n        x = self.output_layer(x)\n        x = F.sigmoid(x)\n        <span class=\"hljs-keyword\">return</span> x\n\n</code></pre>\n<h3>Training it!!!</h3>\n<p>The most interesting part. Let's now load the data and train the neural net.</p>\n<p><a href=\"https://github.com/krkartikay/chess-sl/blob/main/train.py\">train.py</a></p>\n<pre><code class=\"hljs language-py\"><span class=\"hljs-keyword\">import</span> torch\n<span class=\"hljs-keyword\">import</span> torch.nn.functional <span class=\"hljs-keyword\">as</span> F\n\n<span class=\"hljs-keyword\">from</span> torch.utils.data <span class=\"hljs-keyword\">import</span> TensorDataset, DataLoader\n<span class=\"hljs-keyword\">from</span> torch.optim <span class=\"hljs-keyword\">import</span> SGD\n\n<span class=\"hljs-keyword\">from</span> model <span class=\"hljs-keyword\">import</span> ChessModel\n\nBATCH_SIZE = <span class=\"hljs-number\">64</span>\nLEARNING_RATE = <span class=\"hljs-number\">0.1</span>\nNUM_EPOCHS = <span class=\"hljs-number\">10</span>\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Loading data...\"</span>)\n\n<span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">\"games.pth\"</span>, <span class=\"hljs-string\">\"rb\"</span>) <span class=\"hljs-keyword\">as</span> datafile:\n    data = torch.load(datafile)\n    positions: torch.Tensor = data[<span class=\"hljs-string\">\"positions\"</span>]\n    valid_moves: torch.Tensor = data[<span class=\"hljs-string\">\"moves\"</span>].<span class=\"hljs-built_in\">float</span>()\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Loaded data. Shape: \"</span>)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"positions : <span class=\"hljs-subst\">{positions.size()}</span>\"</span>)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"moves     : <span class=\"hljs-subst\">{valid_moves.size()}</span>\"</span>)\n<span class=\"hljs-built_in\">print</span>()\n\nchess_model = ChessModel()\n\ndataset = TensorDataset(positions, valid_moves)\ndataloader = DataLoader(dataset, batch_size=BATCH_SIZE, shuffle=<span class=\"hljs-literal\">True</span>)\n\nsgd_optimizer = SGD(chess_model.parameters(), lr=LEARNING_RATE)\n\n<span class=\"hljs-keyword\">for</span> epochs <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(NUM_EPOCHS):\n    <span class=\"hljs-keyword\">for</span> positions, valid_moves <span class=\"hljs-keyword\">in</span> dataloader:\n        sgd_optimizer.zero_grad()\n\n        move_probs = chess_model(positions)\n        loss = F.binary_cross_entropy(move_probs, valid_moves)\n\n        loss.backward()\n        sgd_optimizer.step()\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f\"Loss: <span class=\"hljs-subst\">{loss.item():<span class=\"hljs-number\">.4</span>f}</span>\"</span>)\n\n</code></pre>\n<p>After adding a <a href=\"https://github.com/krkartikay/chess-sl/blob/main/train.py\">bit more code</a>\nfor train-test dataset splitting and test evaluation, here is the output:</p>\n<pre><code>(torch) krkartikay@KartikayLegion:~/code/chess-sl$ time python train.py \nLoading data...\nLoaded data. Shape: \npositions : torch.Size([34511, 7, 8, 8])\nmoves     : torch.Size([34511, 4096])\n\n1/  1, Loss: 0.6942\n1/ 11, Loss: 0.6911\n1/ 21, Loss: 0.6879\n1/ 31, Loss: 0.6850\n1/ 41, Loss: 0.6817\n1/ 51, Loss: 0.6790\n1/ 61, Loss: 0.6754\n1/ 71, Loss: 0.6724\n1/ 81, Loss: 0.6695\n1/ 91, Loss: 0.6660\n1/101, Loss: 0.6633\nEpoch 1, Average Test Loss: 0.6601\n2/  1, Loss: 0.6604\n2/ 11, Loss: 0.6562\n2/ 21, Loss: 0.6543\n...\n9/ 41, Loss: 0.1734\n9/ 51, Loss: 0.1760\n9/ 61, Loss: 0.2043\n9/ 71, Loss: 0.1695\n9/ 81, Loss: 0.1865\n9/ 91, Loss: 0.1619\n9/101, Loss: 0.1730\nEpoch 9, Average Test Loss: 0.1667\n10/  1, Loss: 0.1516\n10/ 11, Loss: 0.1593\n10/ 21, Loss: 0.1572\n10/ 31, Loss: 0.1499\n10/ 41, Loss: 0.1623\n10/ 51, Loss: 0.1674\n10/ 61, Loss: 0.1790\n10/ 71, Loss: 0.1567\n10/ 81, Loss: 0.1516\n10/ 91, Loss: 0.1464\n10/101, Loss: 0.1492\nEpoch 10, Average Test Loss: 0.1475\n\nreal    1m46.265s\nuser    12m57.450s\nsys     0m40.758s\n</code></pre>\n<p>It runs in about one minute on my PC. It kinda works for now. The loss is\ndecreasing, we've gotten a test loss of ~0.14. There's a lot more stuff left to\ndo, for example:</p>\n<ul>\n<li>Plotting the training and validation loss curves.</li>\n<li>Evaluating the network by actually making it play chess.</li>\n<li>Trying out different hyperparams and optimizers.</li>\n<li>Optimising the network, decreasing the loss further.</li>\n<li>Trying convolutional networks.</li>\n</ul>\n<p>(Link to code so far at <a href=\"https://github.com/krkartikay/chess-sl/commit/677fb0146be77a1cfc8ee06944189b79cae4c1ac\">commit <code>677fb01</code></a>.)</p>\n<p>I've made some progress on it locally but I'll update it here later. Getting too\nlate now... see ya!</p>"},"allNotesIndex":{"base_name":"notes","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes","notes_data":[{"id":"quotes","metadata":{"title":"Quotes","date":"2023-03-21"}}],"directories":[{"base_name":"book notes","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/book notes","notes_data":[{"id":"dokkodo","metadata":{"title":"Dokkodo","date":"2023-03-23"}},{"id":"if","metadata":{"title":"\"If\"","date":"2023-03-27"}},{"id":"worry","metadata":{"title":"Worry","date":"2023-03-29"}}],"directories":[{"base_name":"the bhagvad gita","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/book notes/the bhagvad gita","notes_data":[{"id":"chapter_1","metadata":{"title":"Chapter 1","date":"2023-04-06"}},{"id":"chapter_2","metadata":{"title":"Chapter 2","date":"2023-04-08"}},{"id":"index","metadata":{"title":"The Bhagvad Gita","date":"2023-04-06"}}],"directories":[]}]},{"base_name":"economics","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/economics","notes_data":[],"directories":[{"base_name":"microeconomics","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/economics/microeconomics","notes_data":[{"id":"index","metadata":{"title":"Principles of Microeconomics","date":"2023-03-23"}},{"id":"lecture_1","metadata":{"title":"Lecture 1","date":"2023-03-23"}},{"id":"lecture_2","metadata":{"title":"Lecture 2","date":"2023-03-23"}},{"id":"lecture_3","metadata":{"title":"Lecture 3","date":"2023-03-23"}},{"id":"lecture_4","metadata":{"title":"Lecture 4","date":"2023-04-01"}},{"id":"lecture_5","metadata":{"title":"Lecture 5","date":"2023-04-01"}},{"id":"lecture_6","metadata":{"title":"Lecture 6","date":"2023-04-01"}}],"directories":[]}]},{"base_name":"machine learning","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/machine learning","notes_data":[{"id":"cpp-grad","metadata":{"title":"cpp-grad","date":"2023-04-17"}},{"id":"karpathy-lectures","metadata":{"title":"Andrey Karpathy's Lectures","date":"2023-05-14"}},{"id":"study-plan","metadata":{"title":"ML Study plan","date":"2024-01-14"}}],"directories":[{"base_name":"alpha zero","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/machine learning/alpha zero","notes_data":[{"id":"1-the-start","metadata":{"title":"1. The Start","date":"2024-01-14"}},{"id":"2-initial-plan","metadata":{"title":"2. Initial plan","date":"2024-01-14"}},{"id":"3-supervised-learning","metadata":{"title":"3. Supervised Learning","date":"2024-01-15"}},{"id":"_notes","metadata":{"title":"_notes"}}],"directories":[]}]}]}},"__N_SSG":true}