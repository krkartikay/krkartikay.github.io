{"pageProps":{"note_id":"machine learning__cpp-grad","noteData":{"metadata":{"title":"cpp-grad","date":"2023-04-17"},"content":"<hr>\n<h1>Reimplementing Micrograd in C++</h1>\n<h2>Part 1 – An unexpected error</h2>\n<p>I was watching <a href=\"https://www.youtube.com/watch?v=VMj-3S1tku0\">Andrej Karpathy's lecture on micrograd</a> and decided to implement a micrograd-like library in C++. It feels only natural to implement it in C++ because the operations will be more efficient in C++. Also I'd get a chance to write some more C++ code and use some more object oriented features of C++ like operator overloading.</p>\n<p>So at first I naively started implementing micrograd, basically doing what Andrej was doing in Python and mentally translating it into C++ code. However at one point I got stuck on an interesting error.</p>\n<h3>The code</h3>\n<p>The initial part of micrograd is basically about creating an expression graph of variables and operators and using that expression graph to then traverse backward and update the gradients. I had basically created the expression graph and was trying to print it out while traversing it recursively that I noticed a problem.</p>\n<p>Here's the code I had till then:</p>\n<p><code>main.cpp</code></p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;iostream></span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">\"engine.h\"</span></span>\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-function\">Value <span class=\"hljs-title\">a</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2.0</span>)</span></span>;\n  <span class=\"hljs-function\">Value <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">-3.0</span>)</span></span>;\n  <span class=\"hljs-function\">Value <span class=\"hljs-title\">c</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10.0</span>)</span></span>;\n  Value d = a * b + c;\n  std::cout &#x3C;&#x3C; d.<span class=\"hljs-built_in\">dbg</span>() &#x3C;&#x3C; <span class=\"hljs-string\">\"\\n\"</span>;\n}\n</code></pre>\n<p><code>engine.h</code></p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;iostream></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;ostream></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;set></span></span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Value</span> {\n <span class=\"hljs-keyword\">public</span>:\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Value</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> data)</span> : data_(data) {</span>}\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Value</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> data, std::set&#x3C;<span class=\"hljs-type\">const</span> Value *> prev, <span class=\"hljs-type\">char</span> op)</span>\n      : data_(data), prev_(prev), op_(op){</span>};\n\n  <span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">data</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>{ <span class=\"hljs-keyword\">return</span> data_; }\n\n  <span class=\"hljs-keyword\">friend</span> std::ostream &#x26;<span class=\"hljs-keyword\">operator</span>&#x3C;&#x3C;(std::ostream &#x26;out, Value v);\n\n  Value <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> Value &#x26;other) <span class=\"hljs-type\">const</span>;\n  Value <span class=\"hljs-keyword\">operator</span>*(<span class=\"hljs-type\">const</span> Value &#x26;other) <span class=\"hljs-type\">const</span>;\n\n  <span class=\"hljs-function\">std::string <span class=\"hljs-title\">dbg</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;\n\n <span class=\"hljs-keyword\">private</span>:\n  <span class=\"hljs-type\">double</span> data_ = <span class=\"hljs-number\">0</span>;\n  std::set&#x3C;<span class=\"hljs-type\">const</span> Value *> prev_;\n  <span class=\"hljs-type\">char</span> op_ = <span class=\"hljs-number\">0</span>;\n};\n</code></pre>\n<p><code>engine.cpp</code></p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">\"engine.h\"</span></span>\n\nstd::ostream &#x26;<span class=\"hljs-keyword\">operator</span>&#x3C;&#x3C;(std::ostream &#x26;out, Value v) {\n  <span class=\"hljs-keyword\">return</span> out &#x3C;&#x3C; <span class=\"hljs-string\">\"Value(\"</span> &#x3C;&#x3C; v.<span class=\"hljs-built_in\">data</span>() &#x3C;&#x3C; <span class=\"hljs-string\">\")\"</span>;\n}\n\nValue Value::<span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> Value &#x26;other) <span class=\"hljs-type\">const</span> {\n  Value out = <span class=\"hljs-built_in\">Value</span>(<span class=\"hljs-built_in\">data</span>() + other.<span class=\"hljs-built_in\">data</span>(), {<span class=\"hljs-keyword\">this</span>, &#x26;other}, <span class=\"hljs-string\">'*'</span>);\n  <span class=\"hljs-keyword\">return</span> out;\n}\n\nValue Value::<span class=\"hljs-keyword\">operator</span>*(<span class=\"hljs-type\">const</span> Value &#x26;other) <span class=\"hljs-type\">const</span> {\n  Value out = <span class=\"hljs-built_in\">Value</span>(<span class=\"hljs-built_in\">data</span>() * other.<span class=\"hljs-built_in\">data</span>(), {<span class=\"hljs-keyword\">this</span>, &#x26;other}, <span class=\"hljs-string\">'*'</span>);\n  <span class=\"hljs-keyword\">return</span> out;\n}\n\n<span class=\"hljs-function\">std::string <span class=\"hljs-title\">Value::dbg</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (op_) {\n    std::string children_dbg;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> Value *v : prev_) {\n      children_dbg += v-><span class=\"hljs-built_in\">dbg</span>() + <span class=\"hljs-string\">\", \"</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Value(data=\"</span> + std::<span class=\"hljs-built_in\">to_string</span>(<span class=\"hljs-built_in\">data</span>()) + <span class=\"hljs-string\">\",op=\"</span> + op_ +\n           <span class=\"hljs-string\">\",prev={\"</span> + children_dbg + <span class=\"hljs-string\">\"})\"</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Value(data=\"</span> + std::<span class=\"hljs-built_in\">to_string</span>(<span class=\"hljs-built_in\">data</span>()) + <span class=\"hljs-string\">\")\"</span>;\n}\n</code></pre>\n<p>(Note that Andrej did not define a <code>dbg</code> function like me, instead he had defined a couple of functions to print out the graph in a graphviz format which also renders it in the jupyter notebook, but since I was doing it in C++, the <code>dbg</code> function would have to do for now.)</p>\n<h3>The problem:</h3>\n<pre><code class=\"hljs language-sh\">@krkartikay ➜ /workspaces/cpp-grad (main) $ make &#x26;&#x26; ./main\ng++ main.cpp engine.cpp nn.cpp -o main\nSegmentation fault (core dumped)\n</code></pre>\n<p>So, can you figure out what went wrong? There's only one place where the crash could happen, when we call <code>v->dbg()</code> and dereference the pointer <code>v</code>, because there is no other place where we're dereferencing a pointer. But why did it crash? It looks like we're initialising the pointers with the correct values, and there shouldn't be any <code>nullptr</code>s anywhere. So what's the problem then?</p>\n<p>Here's a hint, the code worked when I changed the following lines in <code>main.cpp</code>:</p>\n<pre><code class=\"hljs language-cpp\">  Value d = a * b + c;\n  std::cout &#x3C;&#x3C; d.<span class=\"hljs-built_in\">dbg</span>() &#x3C;&#x3C; <span class=\"hljs-string\">\"\\n\"</span>;\n</code></pre>\n<p>to this:</p>\n<pre><code class=\"hljs language-cpp\">  Value d = a * b;\n  Value e = d + c;\n  std::cout &#x3C;&#x3C; e.<span class=\"hljs-built_in\">dbg</span>() &#x3C;&#x3C; <span class=\"hljs-string\">\"\\n\"</span>;\n</code></pre>\n<p>And this was the output then:</p>\n<pre><code>@krkartikay ➜ /workspaces/cpp-grad (main) $ make &#x26;&#x26; ./main\ng++ main.cpp engine.cpp nn.cpp -o main\nValue(data=4.000000,op=*,prev={Value(data=10.000000), Value(data=-6.000000,op=*,prev={Value(data=2.000000), Value(data=-3.000000), }), })\n</code></pre>\n<p>So here's basically what's happening. When we are evaluating <code>a * b + c</code>, <code>(a * b)</code> first creates a temporary object that gets added with <code>c</code> and the node <code>d</code> (the output node) contains a pointer to the temporary object <code>(a * b)</code>. This temporary object gets destructed as soon as the expression finishes evaluating and we reach the next line (<code>d.dbg()</code>). So when we call <code>v->dbg()</code> on this node, the <code>v</code> pointer points to a destructed object. This is a problem that wouldn't happen in Python because all objects are created on the heap and the garbage collector takes care of reference counting and doesn't delete this object as it still has one reference.</p>\n<h3>The solution</h3>\n<p>So how do we solve this problem? I got stuck on this problem because while I understood what's going wrong, the best solution wasn't immediately obvious to me. However after some thinking I decided that maybe doing something like what Python does is the best approach. We can let the Value class be a wrapper for a smart-pointer like object, which creates the actual object on the heap and does the reference counting, while it also has the right operator-overloads for writing expressions like this.</p>\n<p>I wanted to write code to fix this problem, but then I thought it was too boring. Let's ask ChatGPT instead? I first wanted to see if GPT-4 understands the problem. I gave it all the above text up to the point where I ask, \"So, can you figure out what went wrong?\".</p>\n<p>Here's what it gave me:</p>\n<blockquote>\n<p>It looks like you are running into a segmentation fault while trying to print the expression graph. The segmentation fault usually occurs when a program tries to access memory that it is not allowed to. In your case, it seems to be related to the recursive traversal of the expression graph when calling the <code>dbg()</code> function.</p>\n<p>After analyzing your code, I have noticed an issue in the Value::operator+ function:</p>\n<pre><code class=\"hljs language-cpp\">Value Value::<span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> Value &#x26;other) <span class=\"hljs-type\">const</span> {\n  Value out = <span class=\"hljs-built_in\">Value</span>(<span class=\"hljs-built_in\">data</span>() + other.<span class=\"hljs-built_in\">data</span>(), {<span class=\"hljs-keyword\">this</span>, &#x26;other}, <span class=\"hljs-string\">'*'</span>);\n  <span class=\"hljs-keyword\">return</span> out;\n}\n</code></pre>\n<p>Here, you are initializing out with an <code>op_</code> value of '*', which should be '+' instead, as this is the addition operator. However, this is not the primary cause of the segmentation fault.</p>\n<p>The main issue lies in the fact that you are storing pointers to local Value objects in the <code>prev_</code> set. When you create a new Value object inside the <code>operator+</code> and <code>operator*</code> functions, these objects have local scope and will be destroyed once the function returns. As a result, the pointers stored in the <code>prev_</code> set of the parent Value object will become dangling pointers, pointing to invalid memory locations.</p>\n<p>To fix the issue, you need to manage the memory for the Value objects more carefully. One way to do this is to use dynamic memory allocation with smart pointers. You can use <code>std::shared_ptr</code> to manage the memory of Value objects, which will automatically deallocate the memory when there are no more references to the object.</p>\n<p>Here's an updated version of your code using <code>std::shared_ptr</code>: ...</p>\n</blockquote>\n<p>It did find out the issue and fix it! That too in the first try. I'm impressed! And it even found an unrelated mistake. I bet you didn't see that either. The solution it suggested was something like this, to modify the Value class to hold a set of <code>shared_ptr</code>'s instead:</p>\n<pre><code class=\"hljs language-cpp\">std::set&#x3C;std::shared_ptr&#x3C;<span class=\"hljs-type\">const</span> Value>> prev_;\n</code></pre>\n<p>and to define the operators like this:</p>\n<pre><code class=\"hljs language-cpp\">Value Value::<span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> Value &#x26;other) <span class=\"hljs-type\">const</span> {\n  Value out = <span class=\"hljs-built_in\">Value</span>(<span class=\"hljs-built_in\">data</span>() + other.<span class=\"hljs-built_in\">data</span>(),\n                    {std::<span class=\"hljs-built_in\">make_shared</span>&#x3C;Value>(*<span class=\"hljs-keyword\">this</span>),\n                     std::<span class=\"hljs-built_in\">make_shared</span>&#x3C;Value>(other)}, <span class=\"hljs-string\">'+'</span>);\n  <span class=\"hljs-keyword\">return</span> out;\n}\n</code></pre>\n<p>However I was worried with this solution that it may create duplicate nodes and not understand that some nodes are shared. I asked it to explain the difference between <code>shared_ptr</code> and <code>unique_ptr</code> and this is what it told me:</p>\n<blockquote>\n<p><code>std::shared_ptr</code> is a smart pointer provided by the C++ Standard Library that manages shared ownership of a dynamically allocated object. It keeps track of the number of <code>shared_ptr</code> instances referring to the same object, using reference counting. When the last <code>shared_ptr</code> that owns the object is destroyed or reset, the object is automatically deleted.</p>\n<p>In the updated program, <code>std::shared_ptr</code> ensures that the temporary <code>Value</code> objects are not deleted prematurely by managing their lifetime based on reference counts. When you create a <code>shared_ptr</code> for a Value object inside the operator+ and operator* functions, the reference count for the object is increased. These <code>shared_ptr</code> instances are then stored in the <code>prev_</code> set of the parent Value object. As long as there is at least one <code>shared_ptr</code> referring to the object, it won't be deleted.</p>\n<p>When the parent Value object is destroyed or goes out of scope, the <code>shared_ptr</code> instances in the <code>prev_</code> set are also destroyed, which in turn decreases the reference count for the child Value objects. If the reference count reaches zero, the object is deleted automatically, ensuring proper memory management.</p>\n<p><code>std::unique_ptr</code> is another smart pointer provided by the C++ Standard Library that manages the exclusive ownership of a dynamically allocated object. Unlike <code>std::shared_ptr</code>, it doesn't use reference counting, as it is designed to have only one owner at a time. When a unique_ptr is destroyed or reset, the object it owns is automatically deleted.</p>\n<p>The main differences between <code>std::shared_ptr</code> and <code>std::unique_ptr</code> are:</p>\n<ol>\n<li>Ownership: <code>std::shared_ptr</code> allows shared ownership, meaning multiple <code>shared_ptr</code> instances can own the same object. In contrast, <code>std::unique_ptr</code> enforces exclusive ownership, with only one <code>unique_ptr</code> owning the object at any given time.</li>\n<li>Reference counting: <code>std::shared_ptr</code> uses reference counting to keep track of the number of instances owning the same object. This adds some overhead compared to <code>std::unique_ptr</code>, which doesn't use reference counting.</li>\n<li>Copying and assignment: <code>std::shared_ptr</code> can be copied and assigned to other <code>shared_ptr</code> instances, which increases the reference count. <code>std::unique_ptr</code> cannot be copied, but it can be moved using <code>std::move</code>, transferring ownership to another <code>unique_ptr</code>.</li>\n<li>In the provided example, <code>std::shared_ptr</code> is more suitable because the expression graph requires shared ownership of the Value objects, and the lifetime of the objects needs to be managed based on reference counts. <code>std::unique_ptr</code> wouldn't be appropriate in this case, as it enforces exclusive ownership and doesn't support reference counting.</li>\n</ol>\n</blockquote>\n<p>I also asked it about my wrapper solution, and here's what it said:</p>\n<blockquote>\n<p>Would it be better if instead of modifying the Value class to hold shared_ptrs in the <code>prev_</code> set, I create a new set of nodes elsewhere and let the Value class be a wrapper for a <code>shared_ptr</code> pointing to a <code>ValueNode</code> in the set?</p>\n</blockquote>\n<blockquote>\n<p>Yes, that could be a good alternative design. By creating a separate set of nodes elsewhere and making the Value class a wrapper for a shared_ptr pointing to a ValueNode in the set, you can achieve the desired behavior while keeping the Value class simpler and more focused on its purpose.</p>\n</blockquote>\n<blockquote>\n<p>Here's a possible implementation of this design: ...</p>\n</blockquote>\n<p>I also tried asking it for various other modifications like adding a tagging functionality etc, and it did all of it perfectly.\nThis is the final code I got, written entirely* by GPT-4:</p>\n<p>[* Of course the GPT-4 output did not compile directly. It even had a couple of minor syntax errors. But I only had to change a few lines to fix it, it had gotten very close to the solution. But then I wouldn't expect even my own code to compile on first try.]</p>\n<p><code>main.cpp</code></p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;iostream></span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">\"value.h\"</span></span>\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-function\">Value <span class=\"hljs-title\">a</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2.0</span>)</span></span>;\n  Value b = a; <span class=\"hljs-comment\">// b shares the same underlying ValueNode as a</span>\n  Value c = b * a;\n  std::cout &#x3C;&#x3C; <span class=\"hljs-string\">\"a: \"</span> &#x3C;&#x3C; a.<span class=\"hljs-built_in\">dbg</span>() &#x3C;&#x3C; <span class=\"hljs-string\">\"\\n\"</span>;\n  std::cout &#x3C;&#x3C; <span class=\"hljs-string\">\"b: \"</span> &#x3C;&#x3C; b.<span class=\"hljs-built_in\">dbg</span>() &#x3C;&#x3C; <span class=\"hljs-string\">\"\\n\"</span>;\n  std::cout &#x3C;&#x3C; <span class=\"hljs-string\">\"c: \"</span> &#x3C;&#x3C; c.<span class=\"hljs-built_in\">dbg</span>() &#x3C;&#x3C; <span class=\"hljs-string\">\"\\n\"</span>;\n\n  <span class=\"hljs-function\">Value <span class=\"hljs-title\">d</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3.0</span>)</span></span>;\n  Value e = d * d;\n  std::cout &#x3C;&#x3C; <span class=\"hljs-string\">\"d: \"</span> &#x3C;&#x3C; d.<span class=\"hljs-built_in\">dbg</span>() &#x3C;&#x3C; <span class=\"hljs-string\">\"\\n\"</span>;\n  std::cout &#x3C;&#x3C; <span class=\"hljs-string\">\"e: \"</span> &#x3C;&#x3C; e.<span class=\"hljs-built_in\">dbg</span>() &#x3C;&#x3C; <span class=\"hljs-string\">\"\\n\"</span>;\n  \n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<p><code>value.h</code></p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> once</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;memory></span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">\"value_node.h\"</span></span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Value</span> {\n <span class=\"hljs-keyword\">public</span>:\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Value</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> data)</span></span>;\n\n  <span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">data</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;\n\n  <span class=\"hljs-keyword\">friend</span> std::ostream &#x26;<span class=\"hljs-keyword\">operator</span>&#x3C;&#x3C;(std::ostream &#x26;out, <span class=\"hljs-type\">const</span> Value &#x26;v);\n\n  Value <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> Value &#x26;other) <span class=\"hljs-type\">const</span>;\n  Value <span class=\"hljs-keyword\">operator</span>*(<span class=\"hljs-type\">const</span> Value &#x26;other) <span class=\"hljs-type\">const</span>;\n\n  <span class=\"hljs-function\">std::string <span class=\"hljs-title\">dbg</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;\n\n <span class=\"hljs-keyword\">private</span>:\n  <span class=\"hljs-built_in\">Value</span>();\n  std::shared_ptr&#x3C;ValueNode> node_;\n};\n</code></pre>\n<p><code>value.cpp</code></p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">\"value.h\"</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;set></span></span>\n\nValue::<span class=\"hljs-built_in\">Value</span>(<span class=\"hljs-type\">double</span> data)\n    : <span class=\"hljs-built_in\">node_</span>(std::<span class=\"hljs-built_in\">make_shared</span>&#x3C;ValueNode>(data)) {}\n\nValue::<span class=\"hljs-built_in\">Value</span>() {}\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">Value::data</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>{ <span class=\"hljs-keyword\">return</span> node_-><span class=\"hljs-built_in\">data</span>(); }\n\nstd::ostream &#x26;<span class=\"hljs-keyword\">operator</span>&#x3C;&#x3C;(std::ostream &#x26;out, <span class=\"hljs-type\">const</span> Value &#x26;v) {\n  <span class=\"hljs-keyword\">return</span> out &#x3C;&#x3C; <span class=\"hljs-string\">\"Value(\"</span> &#x3C;&#x3C; v.<span class=\"hljs-built_in\">data</span>() &#x3C;&#x3C; <span class=\"hljs-string\">\")\"</span>;\n}\n\nValue Value::<span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> Value &#x26;other) <span class=\"hljs-type\">const</span> {\n  <span class=\"hljs-keyword\">auto</span> node = std::<span class=\"hljs-built_in\">make_shared</span>&#x3C;ValueNode>(\n      <span class=\"hljs-built_in\">data</span>() + other.<span class=\"hljs-built_in\">data</span>(),\n      std::set&#x3C;std::shared_ptr&#x3C;ValueNode>>({node_, other.node_}),\n      <span class=\"hljs-string\">'+'</span>);\n  Value out;\n  out.node_ = node;\n  <span class=\"hljs-keyword\">return</span> out;\n}\n\nValue Value::<span class=\"hljs-keyword\">operator</span>*(<span class=\"hljs-type\">const</span> Value &#x26;other) <span class=\"hljs-type\">const</span> {\n  <span class=\"hljs-keyword\">auto</span> node = std::<span class=\"hljs-built_in\">make_shared</span>&#x3C;ValueNode>(\n      <span class=\"hljs-built_in\">data</span>() * other.<span class=\"hljs-built_in\">data</span>(),\n      std::set&#x3C;std::shared_ptr&#x3C;ValueNode>>({node_, other.node_}),\n      <span class=\"hljs-string\">'*'</span>);\n  Value out;\n  out.node_ = node;\n  <span class=\"hljs-keyword\">return</span> out;\n}\n\n<span class=\"hljs-function\">std::string <span class=\"hljs-title\">Value::dbg</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>{ <span class=\"hljs-keyword\">return</span> node_-><span class=\"hljs-built_in\">dbg</span>(); }\n</code></pre>\n<p><code>value_node.h</code></p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> once</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;iostream></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;memory></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;set></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;string></span></span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ValueNode</span> {\n <span class=\"hljs-keyword\">public</span>:\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">ValueNode</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> data)</span></span>;\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">ValueNode</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> data,\n                     std::set&#x3C;std::shared_ptr&#x3C;ValueNode>> prev,\n                     <span class=\"hljs-type\">char</span> op)</span></span>;\n\n  <span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">data</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;\n  <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">id</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;\n\n  <span class=\"hljs-function\">std::string <span class=\"hljs-title\">dbg</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;\n\n <span class=\"hljs-keyword\">private</span>:\n  <span class=\"hljs-type\">int</span> id_;\n  <span class=\"hljs-type\">double</span> data_ = <span class=\"hljs-number\">0</span>;\n  std::set&#x3C;std::shared_ptr&#x3C;ValueNode>> prev_;\n  <span class=\"hljs-type\">char</span> op_ = <span class=\"hljs-number\">0</span>;\n\n  <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> next_id_;\n};\n</code></pre>\n<p><code>value_node.cpp</code></p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">\"value_node.h\"</span></span>\n\n<span class=\"hljs-type\">int</span> ValueNode::next_id_ = <span class=\"hljs-number\">0</span>;\n\nValueNode::<span class=\"hljs-built_in\">ValueNode</span>(<span class=\"hljs-type\">double</span> data) : <span class=\"hljs-built_in\">id_</span>(next_id_++), <span class=\"hljs-built_in\">data_</span>(data) {}\n\nValueNode::<span class=\"hljs-built_in\">ValueNode</span>(<span class=\"hljs-type\">double</span> data,\n                     std::set&#x3C;std::shared_ptr&#x3C;ValueNode>> prev,\n                     <span class=\"hljs-type\">char</span> op)\n    : <span class=\"hljs-built_in\">id_</span>(next_id_++), <span class=\"hljs-built_in\">data_</span>(data), <span class=\"hljs-built_in\">prev_</span>(prev), <span class=\"hljs-built_in\">op_</span>(op) {}\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">ValueNode::data</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>{ <span class=\"hljs-keyword\">return</span> data_; }\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">ValueNode::id</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>{ <span class=\"hljs-keyword\">return</span> id_; }\n\n<span class=\"hljs-function\">std::string <span class=\"hljs-title\">ValueNode::dbg</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (op_) {\n    std::string children_dbg;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span> &#x26;v : prev_) {\n      children_dbg += v-><span class=\"hljs-built_in\">dbg</span>() + <span class=\"hljs-string\">\", \"</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"ValueNode(id=\"</span> + std::<span class=\"hljs-built_in\">to_string</span>(<span class=\"hljs-built_in\">id</span>()) +\n           <span class=\"hljs-string\">\",data=\"</span> + std::<span class=\"hljs-built_in\">to_string</span>(<span class=\"hljs-built_in\">data</span>()) + <span class=\"hljs-string\">\",op=\"</span> + op_ +\n           <span class=\"hljs-string\">\",prev={\"</span> + children_dbg + <span class=\"hljs-string\">\"})\"</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"ValueNode(id=\"</span> + std::<span class=\"hljs-built_in\">to_string</span>(<span class=\"hljs-built_in\">id</span>()) +\n         <span class=\"hljs-string\">\",data=\"</span> + std::<span class=\"hljs-built_in\">to_string</span>(<span class=\"hljs-built_in\">data</span>()) + <span class=\"hljs-string\">\")\"</span>;\n}\n</code></pre>\n<h4>GPT-4's predicted output:</h4>\n<pre><code class=\"hljs language-cpp\">a: <span class=\"hljs-built_in\">ValueNode</span>(id=<span class=\"hljs-number\">0</span>,data=<span class=\"hljs-number\">2</span>)\nb: <span class=\"hljs-built_in\">ValueNode</span>(id=<span class=\"hljs-number\">0</span>,data=<span class=\"hljs-number\">2</span>)\nc: <span class=\"hljs-built_in\">ValueNode</span>(id=<span class=\"hljs-number\">1</span>,data=<span class=\"hljs-number\">4</span>,op=*,prev={<span class=\"hljs-built_in\">ValueNode</span>(id=<span class=\"hljs-number\">0</span>,data=<span class=\"hljs-number\">2</span>), <span class=\"hljs-built_in\">ValueNode</span>(id=<span class=\"hljs-number\">0</span>,data=<span class=\"hljs-number\">2</span>)})\nd: <span class=\"hljs-built_in\">ValueNode</span>(id=<span class=\"hljs-number\">2</span>,data=<span class=\"hljs-number\">3</span>)\ne: <span class=\"hljs-built_in\">ValueNode</span>(id=<span class=\"hljs-number\">3</span>,data=<span class=\"hljs-number\">9</span>,op=*,prev={<span class=\"hljs-built_in\">ValueNode</span>(id=<span class=\"hljs-number\">2</span>,data=<span class=\"hljs-number\">3</span>), <span class=\"hljs-built_in\">ValueNode</span>(id=<span class=\"hljs-number\">2</span>,data=<span class=\"hljs-number\">3</span>)})\n</code></pre>\n<h4>Actual Output:</h4>\n<pre><code class=\"hljs language-cpp\">a: <span class=\"hljs-built_in\">ValueNode</span>(id=<span class=\"hljs-number\">0</span>,data=<span class=\"hljs-number\">2.000000</span>)\nb: <span class=\"hljs-built_in\">ValueNode</span>(id=<span class=\"hljs-number\">0</span>,data=<span class=\"hljs-number\">2.000000</span>)\nc: <span class=\"hljs-built_in\">ValueNode</span>(id=<span class=\"hljs-number\">1</span>,data=<span class=\"hljs-number\">4.000000</span>,op=*,prev={<span class=\"hljs-built_in\">ValueNode</span>(id=<span class=\"hljs-number\">0</span>,data=<span class=\"hljs-number\">2.000000</span>), })\nd: <span class=\"hljs-built_in\">ValueNode</span>(id=<span class=\"hljs-number\">2</span>,data=<span class=\"hljs-number\">3.000000</span>)\ne: <span class=\"hljs-built_in\">ValueNode</span>(id=<span class=\"hljs-number\">3</span>,data=<span class=\"hljs-number\">9.000000</span>,op=*,prev={<span class=\"hljs-built_in\">ValueNode</span>(id=<span class=\"hljs-number\">2</span>,data=<span class=\"hljs-number\">3.000000</span>), })\n</code></pre>\n<h3>Bonus?</h3>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-comment\">// Add these includes at the beginning of the file</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;sstream></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;unordered_set></span></span>\n\n<span class=\"hljs-comment\">// Add this function declaration in the `Value` class</span>\n<span class=\"hljs-function\">std::string <span class=\"hljs-title\">to_graphviz</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;\n</code></pre>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-comment\">// Helper function for the recursive traversal</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">traverse_graphviz</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> Value &#x26;v, std::unordered_set&#x3C;<span class=\"hljs-type\">const</span> Value *> &#x26;visited, std::stringstream &#x26;ss)</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (visited.<span class=\"hljs-built_in\">count</span>(&#x26;v) == <span class=\"hljs-number\">0</span>) {\n    visited.<span class=\"hljs-built_in\">insert</span>(&#x26;v);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span> &#x26;prev : v.prev_) {\n      ss &#x3C;&#x3C; <span class=\"hljs-string\">\"\\\"\"</span> &#x3C;&#x3C; prev->id_ &#x3C;&#x3C; <span class=\"hljs-string\">\"\\\" -> \\\"\"</span> &#x3C;&#x3C; v.id_ &#x3C;&#x3C; <span class=\"hljs-string\">\"\\\";\\n\"</span>;\n      <span class=\"hljs-built_in\">traverse_graphviz</span>(*prev, visited, ss);\n    }\n\n    ss &#x3C;&#x3C; <span class=\"hljs-string\">\"\\\"\"</span> &#x3C;&#x3C; v.id_ &#x3C;&#x3C; <span class=\"hljs-string\">\"\\\" [label=\\\"Value(id=\"</span> &#x3C;&#x3C; v.id_ &#x3C;&#x3C; <span class=\"hljs-string\">\", data=\"</span> &#x3C;&#x3C; v.data_ &#x3C;&#x3C; <span class=\"hljs-string\">\", op=\"</span> &#x3C;&#x3C; (v.op_ ? v.op_ : <span class=\"hljs-string\">' '</span>) &#x3C;&#x3C; <span class=\"hljs-string\">\")\\\"];\\n\"</span>;\n  }\n}\n\n<span class=\"hljs-comment\">// to_graphviz function implementation</span>\n<span class=\"hljs-function\">std::string <span class=\"hljs-title\">Value::to_graphviz</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>{\n  std::stringstream ss;\n  std::unordered_set&#x3C;<span class=\"hljs-type\">const</span> Value *> visited;\n\n  ss &#x3C;&#x3C; <span class=\"hljs-string\">\"digraph G {\\n\"</span>;\n  <span class=\"hljs-built_in\">traverse_graphviz</span>(*<span class=\"hljs-keyword\">this</span>, visited, ss);\n  ss &#x3C;&#x3C; <span class=\"hljs-string\">\"}\\n\"</span>;\n\n  <span class=\"hljs-keyword\">return</span> ss.<span class=\"hljs-built_in\">str</span>();\n}\n</code></pre>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;iostream></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">\"value.h\"</span></span>\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-function\">Value <span class=\"hljs-title\">a</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2.0</span>)</span></span>;\n  <span class=\"hljs-function\">Value <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">-3.0</span>)</span></span>;\n  <span class=\"hljs-function\">Value <span class=\"hljs-title\">c</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10.0</span>)</span></span>;\n  Value d = a * b + c;\n  std::cout &#x3C;&#x3C; d.<span class=\"hljs-built_in\">to_graphviz</span>() &#x3C;&#x3C; std::endl;\n}\n</code></pre>\n<p>Output:</p>\n<p><img src=\"/cpp_grad_graph.png\" alt=\"graph output from graphviz\"></p>\n<h3>Conclusions</h3>\n<p>Maybe C++ is not really the best way to do these things. Writing code manually is slow and inefficient. GPT-4 is way too cool. It's probably time to learn PyTorch now.</p>"},"allNotesIndex":{"base_name":"notes","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes","notes_data":[{"id":"quotes","metadata":{"title":"Quotes","date":"2023-03-21"}}],"directories":[{"base_name":"book notes","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/book notes","notes_data":[{"id":"dokkodo","metadata":{"title":"Dokkodo","date":"2023-03-23"}},{"id":"if","metadata":{"title":"\"If\"","date":"2023-03-27"}},{"id":"worry","metadata":{"title":"Worry","date":"2023-03-29"}}],"directories":[{"base_name":"the bhagvad gita","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/book notes/the bhagvad gita","notes_data":[{"id":"chapter_1","metadata":{"title":"Chapter 1","date":"2023-04-06"}},{"id":"chapter_2","metadata":{"title":"Chapter 2","date":"2023-04-08"}},{"id":"index","metadata":{"title":"The Bhagvad Gita","date":"2023-04-06"}}],"directories":[]}]},{"base_name":"economics","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/economics","notes_data":[],"directories":[{"base_name":"microeconomics","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/economics/microeconomics","notes_data":[{"id":"index","metadata":{"title":"Principles of Microeconomics","date":"2023-03-23"}},{"id":"lecture_1","metadata":{"title":"Lecture 1","date":"2023-03-23"}},{"id":"lecture_2","metadata":{"title":"Lecture 2","date":"2023-03-23"}},{"id":"lecture_3","metadata":{"title":"Lecture 3","date":"2023-03-23"}},{"id":"lecture_4","metadata":{"title":"Lecture 4","date":"2023-04-01"}},{"id":"lecture_5","metadata":{"title":"Lecture 5","date":"2023-04-01"}},{"id":"lecture_6","metadata":{"title":"Lecture 6","date":"2023-04-01"}}],"directories":[]}]},{"base_name":"machine learning","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/machine learning","notes_data":[{"id":"cpp-grad","metadata":{"title":"cpp-grad","date":"2023-04-17"}},{"id":"karpathy-lectures","metadata":{"title":"Andrey Karpathy's Lectures","date":"2023-05-14"}}],"directories":[]}]}},"__N_SSG":true}