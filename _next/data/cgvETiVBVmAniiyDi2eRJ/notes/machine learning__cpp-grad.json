{"pageProps":{"note_id":"machine learning__cpp-grad","noteData":{"metadata":{"title":"cpp-grad","date":"2023-04-17"},"content":"<hr>\n<h1>Reimplementing Micrograd in C++</h1>\n<h2>Part 1 – An unexpected error</h2>\n<p>I was watching <a href=\"https://www.youtube.com/watch?v=VMj-3S1tku0\">Andrej Karpathy's lecture on micrograd</a> and decided to implement a micrograd-like library in C++. It feels only natural to implement it in C++ because the operations will be more efficient in C++. Also I'd get a chance to write some more C++ code and use some more object oriented features of C++ like operator overloading.</p>\n<p>So at first I naively started implementing micrograd, basically doing what Andrej was doing in Python and mentally translating it into C++ code. However at one point I got stuck on an interesting error.</p>\n<h3>The code</h3>\n<p>The initial part of micrograd is basically about creating an expression graph of variables and operators and using that expression graph to then traverse backward and update the gradients. I had basically created the expression graph and was trying to print it out while traversing it recursively that I noticed a problem.</p>\n<p>Here's the code I had till then:</p>\n<p><code>main.cpp</code></p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;iostream></span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">\"engine.h\"</span></span>\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-function\">Value <span class=\"hljs-title\">a</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2.0</span>)</span></span>;\n  <span class=\"hljs-function\">Value <span class=\"hljs-title\">b</span><span class=\"hljs-params\">(<span class=\"hljs-number\">-3.0</span>)</span></span>;\n  <span class=\"hljs-function\">Value <span class=\"hljs-title\">c</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10.0</span>)</span></span>;\n  Value d = a * b + c;\n  std::cout &#x3C;&#x3C; d.<span class=\"hljs-built_in\">dbg</span>() &#x3C;&#x3C; <span class=\"hljs-string\">\"\\n\"</span>;\n}\n</code></pre>\n<p><code>engine.h</code></p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;iostream></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;ostream></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;set></span></span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Value</span> {\n <span class=\"hljs-keyword\">public</span>:\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Value</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> data)</span> : data_(data) {</span>}\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Value</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> data, std::set&#x3C;<span class=\"hljs-type\">const</span> Value *> prev, <span class=\"hljs-type\">char</span> op)</span>\n      : data_(data), prev_(prev), op_(op){</span>};\n\n  <span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">data</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>{ <span class=\"hljs-keyword\">return</span> data_; }\n\n  <span class=\"hljs-keyword\">friend</span> std::ostream &#x26;<span class=\"hljs-keyword\">operator</span>&#x3C;&#x3C;(std::ostream &#x26;out, Value v);\n\n  Value <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> Value &#x26;other) <span class=\"hljs-type\">const</span>;\n  Value <span class=\"hljs-keyword\">operator</span>*(<span class=\"hljs-type\">const</span> Value &#x26;other) <span class=\"hljs-type\">const</span>;\n\n  <span class=\"hljs-function\">std::string <span class=\"hljs-title\">dbg</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;\n\n <span class=\"hljs-keyword\">private</span>:\n  <span class=\"hljs-type\">double</span> data_ = <span class=\"hljs-number\">0</span>;\n  std::set&#x3C;<span class=\"hljs-type\">const</span> Value *> prev_;\n  <span class=\"hljs-type\">char</span> op_ = <span class=\"hljs-number\">0</span>;\n};\n</code></pre>\n<p><code>engine.cpp</code></p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">\"engine.h\"</span></span>\n\nstd::ostream &#x26;<span class=\"hljs-keyword\">operator</span>&#x3C;&#x3C;(std::ostream &#x26;out, Value v) {\n  <span class=\"hljs-keyword\">return</span> out &#x3C;&#x3C; <span class=\"hljs-string\">\"Value(\"</span> &#x3C;&#x3C; v.<span class=\"hljs-built_in\">data</span>() &#x3C;&#x3C; <span class=\"hljs-string\">\")\"</span>;\n}\n\nValue Value::<span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> Value &#x26;other) <span class=\"hljs-type\">const</span> {\n  Value out = <span class=\"hljs-built_in\">Value</span>(<span class=\"hljs-built_in\">data</span>() + other.<span class=\"hljs-built_in\">data</span>(), {<span class=\"hljs-keyword\">this</span>, &#x26;other}, <span class=\"hljs-string\">'*'</span>);\n  <span class=\"hljs-keyword\">return</span> out;\n}\n\nValue Value::<span class=\"hljs-keyword\">operator</span>*(<span class=\"hljs-type\">const</span> Value &#x26;other) <span class=\"hljs-type\">const</span> {\n  Value out = <span class=\"hljs-built_in\">Value</span>(<span class=\"hljs-built_in\">data</span>() * other.<span class=\"hljs-built_in\">data</span>(), {<span class=\"hljs-keyword\">this</span>, &#x26;other}, <span class=\"hljs-string\">'*'</span>);\n  <span class=\"hljs-keyword\">return</span> out;\n}\n\n<span class=\"hljs-function\">std::string <span class=\"hljs-title\">Value::dbg</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>{\n  <span class=\"hljs-keyword\">if</span> (op_) {\n    std::string children_dbg;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> Value *v : prev_) {\n      children_dbg += v-><span class=\"hljs-built_in\">dbg</span>() + <span class=\"hljs-string\">\", \"</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Value(data=\"</span> + std::<span class=\"hljs-built_in\">to_string</span>(<span class=\"hljs-built_in\">data</span>()) + <span class=\"hljs-string\">\",op=\"</span> + op_ +\n           <span class=\"hljs-string\">\",prev={\"</span> + children_dbg + <span class=\"hljs-string\">\"})\"</span>;\n  }\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Value(data=\"</span> + std::<span class=\"hljs-built_in\">to_string</span>(<span class=\"hljs-built_in\">data</span>()) + <span class=\"hljs-string\">\")\"</span>;\n}\n</code></pre>\n<p>(Note that Andrej did not define a <code>dbg</code> function like me, instead he had defined a couple of functions to print out the graph in a graphviz format which also renders it in the jupyter notebook, but since I was doing it in C++, the <code>dbg</code> function would have to do for now.)</p>\n<h3>The problem:</h3>\n<pre><code class=\"hljs language-sh\">@krkartikay ➜ /workspaces/cpp-grad (main) $ make &#x26;&#x26; ./main\ng++ main.cpp engine.cpp nn.cpp -o main\nSegmentation fault (core dumped)\n</code></pre>\n<p>So, can you figure out what went wrong? There's only one place where the crash could happen, when we call <code>v->dbg()</code> and dereference the pointer <code>v</code>, because there is no other place where we're dereferencing a pointer. But why did it crash? It looks like we're initialising the pointers with the correct values, and there shouldn't be any <code>nullptr</code>s anywhere. So what's the problem then?</p>\n<p>Here's a hint, the code worked when I changed the following lines in <code>main.cpp</code>:</p>\n<pre><code class=\"hljs language-cpp\">  Value d = a * b + c;\n  std::cout &#x3C;&#x3C; d.<span class=\"hljs-built_in\">dbg</span>() &#x3C;&#x3C; <span class=\"hljs-string\">\"\\n\"</span>;\n</code></pre>\n<p>to this:</p>\n<pre><code class=\"hljs language-cpp\">  Value d = a * b;\n  Value e = d + c;\n  std::cout &#x3C;&#x3C; e.<span class=\"hljs-built_in\">dbg</span>() &#x3C;&#x3C; <span class=\"hljs-string\">\"\\n\"</span>;\n</code></pre>\n<p>And this was the output then:</p>\n<pre><code>@krkartikay ➜ /workspaces/cpp-grad (main) $ make &#x26;&#x26; ./main\ng++ main.cpp engine.cpp nn.cpp -o main\nValue(data=4.000000,op=*,prev={Value(data=10.000000), Value(data=-6.000000,op=*,prev={Value(data=2.000000), Value(data=-3.000000), }), })\n</code></pre>\n<p>So here's basically what's happening. When we are evaluating <code>a * b + c</code>, <code>(a * b)</code> first creates a temporary object that gets added with <code>c</code> and the node <code>d</code> (the output node) contains a pointer to the temporary object <code>(a * b)</code>. This temporary object gets destructed as soon as the expression finishes evaluating and we reach the next line (<code>d.dbg()</code>). So when we call <code>v->dbg()</code> on this node, the <code>v</code> pointer points to a destructed object. This is a problem that wouldn't happen in Python because all objects are created on the heap and the garbage collector takes care of reference counting and doesn't delete this object as it still has one reference.</p>\n<h3>The solution</h3>\n<p>So how do we solve this problem? I got stuck on this problem because while I understood what's going wrong, the best solution wasn't immediately obvious to me. However after some thinking I decided that maybe doing something like what Python does is the best approach. We can let the Value class be a wrapper for a smart-pointer like object, which creates the actual object on the heap and does the reference counting, while it also has the right operator-overloads for writing expressions like this.</p>\n<p>Here's the code I finally got to after I fixed this problem.</p>\n<h3>Conclusion</h3>\n<p>I realised maybe C++ is not really the best way to do these things. It's probably time to learn PyTorch now.</p>"},"allNotesIndex":{"base_name":"notes","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes","notes_data":[{"id":"quotes","metadata":{"title":"Quotes","date":"2023-03-21"}}],"directories":[{"base_name":"book notes","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/book notes","notes_data":[{"id":"dokkodo","metadata":{"title":"Dokkodo","date":"2023-03-23"}},{"id":"if","metadata":{"title":"\"If\"","date":"2023-03-27"}},{"id":"worry","metadata":{"title":"Worry","date":"2023-03-29"}}],"directories":[{"base_name":"the bhagvad gita","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/book notes/the bhagvad gita","notes_data":[{"id":"chapter_1","metadata":{"title":"Chapter 1","date":"2023-04-06"}},{"id":"chapter_2","metadata":{"title":"Chapter 2","date":"2023-04-08"}},{"id":"index","metadata":{"title":"The Bhagvad Gita","date":"2023-04-06"}}],"directories":[]}]},{"base_name":"economics","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/economics","notes_data":[],"directories":[{"base_name":"microeconomics","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/economics/microeconomics","notes_data":[{"id":"index","metadata":{"title":"Principles of Microeconomics","date":"2023-03-23"}},{"id":"lecture_1","metadata":{"title":"Lecture 1","date":"2023-03-23"}},{"id":"lecture_2","metadata":{"title":"Lecture 2","date":"2023-03-23"}},{"id":"lecture_3","metadata":{"title":"Lecture 3","date":"2023-03-23"}},{"id":"lecture_4","metadata":{"title":"Lecture 4","date":"2023-04-01"}},{"id":"lecture_5","metadata":{"title":"Lecture 5","date":"2023-04-01"}},{"id":"lecture_6","metadata":{"title":"Lecture 6","date":"2023-04-01"}}],"directories":[]}]},{"base_name":"machine learning","full_path":"/home/runner/work/krkartikay.github.io/krkartikay.github.io/notes/machine learning","notes_data":[{"id":"cpp-grad","metadata":{"title":"cpp-grad","date":"2023-04-17"}},{"id":"interview-gpt3","metadata":{"title":"Interview with GPT-3.5","date":"2023-04-21"}},{"id":"interview-gpt4","metadata":{"title":"Interview with GPT-4","date":"2023-04-21"}}],"directories":[]}]}},"__N_SSG":true}